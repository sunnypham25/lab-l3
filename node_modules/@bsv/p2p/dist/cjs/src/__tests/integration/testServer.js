"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.startTestServer = startTestServer;
exports.stopTestServer = stopTestServer;
const child_process_1 = require("child_process");
const path_1 = require("path");
let serverProcess = null;
async function isServerRunning() {
    try {
        await fetch('http://localhost:8080/health'); // Use an actual health check route
        return true;
    }
    catch {
        return false;
    }
}
/**
 * Starts the MessageBoxServer as a separate process if not already running.
 */
async function startTestServer() {
    if (await isServerRunning()) {
        console.log('Test server already running.');
        return;
    }
    console.log('Starting test server...');
    serverProcess = (0, child_process_1.spawn)('npm', ['run', 'dev'], {
        cwd: (0, path_1.resolve)(__dirname, '../../../MessageBoxServer'),
        stdio: 'inherit',
        shell: true
    });
    await new Promise((resolve, reject) => {
        const timeout = setTimeout(() => {
            reject(new Error('Test server startup timed out'));
        }, 10000);
        serverProcess.on('error', (err) => {
            console.error('Test server failed to start:', err);
            clearTimeout(timeout);
            reject(err);
        });
        setTimeout(() => {
            console.log('Test server started.');
            clearTimeout(timeout);
            resolve(undefined);
        }, 3000);
    });
}
/**
 * Stops the MessageBoxServer process after tests.
 */
async function stopTestServer() {
    if (serverProcess === null) {
        console.warn('Test server process is already stopped or undefined.');
        return;
    }
    console.log('Stopping test server...');
    try {
        serverProcess.kill();
        console.log('Test server stopped.');
    }
    catch (error) {
        console.error('Error stopping test server:', error);
    }
    serverProcess = null;
}
//# sourceMappingURL=testServer.js.map