import { AcquireCertificateArgs, AcquireCertificateResult, Base64String, BasketStringUnder300Bytes, BooleanDefaultFalse, Byte, CertificateFieldNameUnder50Bytes, CreateActionArgs, CreateActionResult, DescriptionString5to50Bytes, DiscoverCertificatesResult, HexString, InternalizeActionArgs, ISOTimestampString, KeyIDStringUnder800Bytes, ListActionsArgs, ListActionsResult, ListCertificatesResult, ListOutputsArgs, ListOutputsResult, OriginatorDomainNameStringUnder250Bytes, OutpointString, PositiveInteger, PositiveIntegerDefault10Max10000, PositiveIntegerOrZero, ProtocolString5To400Bytes, ProveCertificateArgs, ProveCertificateResult, PubKeyHex, SecurityLevel, SignActionArgs, SignActionResult, VersionString7To30Bytes, WalletInterface, AuthenticatedResult } from './Wallet.interfaces.js';
/**
 * The SDK is how applications communicate with wallets over a communications substrate.
 */
export default class WalletClient implements WalletInterface {
    substrate: 'auto' | WalletInterface;
    originator?: OriginatorDomainNameStringUnder250Bytes;
    constructor(substrate?: 'auto' | 'Cicada' | 'XDM' | 'window.CWI' | 'json-api' | 'react-native' | WalletInterface, originator?: OriginatorDomainNameStringUnder250Bytes);
    connectToSubstrate(): Promise<void>;
    createAction(args: CreateActionArgs): Promise<CreateActionResult>;
    signAction(args: SignActionArgs): Promise<SignActionResult>;
    abortAction(args: {
        reference: Base64String;
    }): Promise<{
        aborted: true;
    }>;
    listActions(args: ListActionsArgs): Promise<ListActionsResult>;
    internalizeAction(args: InternalizeActionArgs): Promise<{
        accepted: true;
    }>;
    listOutputs(args: ListOutputsArgs): Promise<ListOutputsResult>;
    relinquishOutput(args: {
        basket: BasketStringUnder300Bytes;
        output: OutpointString;
    }): Promise<{
        relinquished: true;
    }>;
    getPublicKey(args: {
        identityKey?: true;
        protocolID?: [SecurityLevel, ProtocolString5To400Bytes];
        keyID?: KeyIDStringUnder800Bytes;
        privileged?: BooleanDefaultFalse;
        privilegedReason?: DescriptionString5to50Bytes;
        counterparty?: PubKeyHex | 'self' | 'anyone';
        forSelf?: BooleanDefaultFalse;
    }): Promise<{
        publicKey: PubKeyHex;
    }>;
    revealCounterpartyKeyLinkage(args: {
        counterparty: PubKeyHex;
        verifier: PubKeyHex;
        privilegedReason?: DescriptionString5to50Bytes;
        privileged?: BooleanDefaultFalse;
    }): Promise<{
        prover: PubKeyHex;
        verifier: PubKeyHex;
        counterparty: PubKeyHex;
        revelationTime: ISOTimestampString;
        encryptedLinkage: Byte[];
        encryptedLinkageProof: Byte[];
    }>;
    revealSpecificKeyLinkage(args: {
        counterparty: PubKeyHex;
        verifier: PubKeyHex;
        protocolID: [SecurityLevel, ProtocolString5To400Bytes];
        keyID: KeyIDStringUnder800Bytes;
        privilegedReason?: DescriptionString5to50Bytes;
        privileged?: BooleanDefaultFalse;
    }): Promise<{
        prover: PubKeyHex;
        verifier: PubKeyHex;
        counterparty: PubKeyHex;
        protocolID: [SecurityLevel, ProtocolString5To400Bytes];
        keyID: KeyIDStringUnder800Bytes;
        encryptedLinkage: Byte[];
        encryptedLinkageProof: Byte[];
        proofType: Byte;
    }>;
    encrypt(args: {
        plaintext: Byte[];
        protocolID: [SecurityLevel, ProtocolString5To400Bytes];
        keyID: KeyIDStringUnder800Bytes;
        privilegedReason?: DescriptionString5to50Bytes;
        counterparty?: PubKeyHex | 'self' | 'anyone';
        privileged?: BooleanDefaultFalse;
    }): Promise<{
        ciphertext: Byte[];
    }>;
    decrypt(args: {
        ciphertext: Byte[];
        protocolID: [SecurityLevel, ProtocolString5To400Bytes];
        keyID: KeyIDStringUnder800Bytes;
        privilegedReason?: DescriptionString5to50Bytes;
        counterparty?: PubKeyHex | 'self' | 'anyone';
        privileged?: BooleanDefaultFalse;
    }): Promise<{
        plaintext: Byte[];
    }>;
    createHmac(args: {
        data: Byte[];
        protocolID: [SecurityLevel, ProtocolString5To400Bytes];
        keyID: KeyIDStringUnder800Bytes;
        privilegedReason?: DescriptionString5to50Bytes;
        counterparty?: PubKeyHex | 'self' | 'anyone';
        privileged?: BooleanDefaultFalse;
    }): Promise<{
        hmac: Byte[];
    }>;
    verifyHmac(args: {
        data: Byte[];
        hmac: Byte[];
        protocolID: [SecurityLevel, ProtocolString5To400Bytes];
        keyID: KeyIDStringUnder800Bytes;
        privilegedReason?: DescriptionString5to50Bytes;
        counterparty?: PubKeyHex | 'self' | 'anyone';
        privileged?: BooleanDefaultFalse;
    }): Promise<{
        valid: true;
    }>;
    createSignature(args: {
        data?: Byte[];
        hashToDirectlySign?: Byte[];
        protocolID: [SecurityLevel, ProtocolString5To400Bytes];
        keyID: KeyIDStringUnder800Bytes;
        privilegedReason?: DescriptionString5to50Bytes;
        counterparty?: PubKeyHex | 'self' | 'anyone';
        privileged?: BooleanDefaultFalse;
    }): Promise<{
        signature: Byte[];
    }>;
    verifySignature(args: {
        data?: Byte[];
        hashToDirectlyVerify?: Byte[];
        signature: Byte[];
        protocolID: [SecurityLevel, ProtocolString5To400Bytes];
        keyID: KeyIDStringUnder800Bytes;
        privilegedReason?: DescriptionString5to50Bytes;
        counterparty?: PubKeyHex | 'self' | 'anyone';
        forSelf?: BooleanDefaultFalse;
        privileged?: BooleanDefaultFalse;
    }): Promise<{
        valid: true;
    }>;
    acquireCertificate(args: AcquireCertificateArgs): Promise<AcquireCertificateResult>;
    listCertificates(args: {
        certifiers: PubKeyHex[];
        types: Base64String[];
        limit?: PositiveIntegerDefault10Max10000;
        offset?: PositiveIntegerOrZero;
        privileged?: BooleanDefaultFalse;
        privilegedReason?: DescriptionString5to50Bytes;
    }): Promise<ListCertificatesResult>;
    proveCertificate(args: ProveCertificateArgs): Promise<ProveCertificateResult>;
    relinquishCertificate(args: {
        type: Base64String;
        serialNumber: Base64String;
        certifier: PubKeyHex;
    }): Promise<{
        relinquished: true;
    }>;
    discoverByIdentityKey(args: {
        identityKey: PubKeyHex;
        limit?: PositiveIntegerDefault10Max10000;
        offset?: PositiveIntegerOrZero;
    }): Promise<DiscoverCertificatesResult>;
    discoverByAttributes(args: {
        attributes: Record<CertificateFieldNameUnder50Bytes, string>;
        limit?: PositiveIntegerDefault10Max10000;
        offset?: PositiveIntegerOrZero;
    }): Promise<DiscoverCertificatesResult>;
    isAuthenticated(args?: object): Promise<AuthenticatedResult>;
    waitForAuthentication(args?: object): Promise<{
        authenticated: true;
    }>;
    getHeight(args?: object): Promise<{
        height: PositiveInteger;
    }>;
    getHeaderForHeight(args: {
        height: PositiveInteger;
    }): Promise<{
        header: HexString;
    }>;
    getNetwork(args?: object): Promise<{
        network: 'mainnet' | 'testnet';
    }>;
    getVersion(args?: object): Promise<{
        version: VersionString7To30Bytes;
    }>;
}
//# sourceMappingURL=WalletClient.d.ts.map