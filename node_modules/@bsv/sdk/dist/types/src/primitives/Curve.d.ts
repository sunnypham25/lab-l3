import BigNumber from './BigNumber.js';
import ReductionContext from './ReductionContext.js';
import Point from './Point.js';
export default class Curve {
    p: BigNumber;
    red: ReductionContext;
    redN: BigNumber | null;
    zero: BigNumber;
    one: BigNumber;
    two: BigNumber;
    g: Point;
    n: BigNumber;
    a: BigNumber;
    b: BigNumber;
    tinv: BigNumber;
    zeroA: boolean;
    threeA: boolean;
    endo: {
        beta: BigNumber;
        lambda: BigNumber;
        basis: Array<{
            a: BigNumber;
            b: BigNumber;
        }>;
    } | undefined;
    _endoWnafT1: BigNumber[];
    _endoWnafT2: BigNumber[];
    _wnafT1: BigNumber[];
    _wnafT2: BigNumber[];
    _wnafT3: BigNumber[];
    _wnafT4: BigNumber[];
    _bitLength: number;
    static assert(expression: unknown, message?: string): void;
    getNAF(num: BigNumber, w: number, bits: number): number[];
    getJSF(k1: BigNumber, k2: BigNumber): number[][];
    static cachedProperty(obj: any, name: string, computer: any): void;
    static parseBytes(bytes: string | number[]): number[];
    static intFromLE(bytes: number[]): BigNumber;
    constructor();
    _getEndomorphism(conf: any): {
        beta: BigNumber;
        lambda: BigNumber;
        basis: Array<{
            a: BigNumber;
            b: BigNumber;
        }>;
    } | undefined;
    _getEndoRoots(num: BigNumber): [BigNumber, BigNumber];
    _getEndoBasis(lambda: BigNumber): [{
        a: BigNumber;
        b: BigNumber;
    }, {
        a: BigNumber;
        b: BigNumber;
    }];
    _endoSplit(k: BigNumber): {
        k1: BigNumber;
        k2: BigNumber;
    };
    validate(point: Point): boolean;
}
//# sourceMappingURL=Curve.d.ts.map