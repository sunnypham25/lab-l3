import { WalletInterface, OutpointString } from '../wallet/Wallet.interfaces.js';
/**
 * Implements a key-value storage system backed by transaction outputs managed by a wallet.
 * Each key-value pair is represented by a PushDrop token output in a specific context (basket).
 * Allows setting, getting, and removing key-value pairs, with optional encryption.
 */
export default class LocalKVStore {
    /**
     * The wallet interface used to manage outputs and perform cryptographic operations.
     * @private
     * @readonly
     */
    private readonly wallet;
    /**
     * The context (basket name) used to namespace the key-value pairs within the wallet.
     * @private
     * @readonly
     */
    private readonly context;
    /**
     * Flag indicating whether values should be encrypted before storing.
     * @private
     * @readonly
     */
    private readonly encrypt;
    /**
     * An originator to use with PushDrop and the wallet.
     * @private
     * @readonly
     */
    private readonly originator?;
    acceptDelayedBroadcast: boolean;
    /**
     * A map to store locks for each key to ensure atomic updates.
     * @private
     */
    private readonly keyLocks;
    /**
     * Creates an instance of the localKVStore.
     *
     * @param {WalletInterface} [wallet=new WalletClient()] - The wallet interface to use. Defaults to a new WalletClient instance.
     * @param {string} [context='kvstoredefault'] - The context (basket) for namespacing keys. Defaults to 'kvstore default'.
     * @param {boolean} [encrypt=true] - Whether to encrypt values. Defaults to true.
     * @param {string} [originator] â€” An originator to use with PushDrop and the wallet, if provided.
     * @throws {Error} If the context is missing or empty.
     */
    constructor(wallet?: WalletInterface, context?: string, encrypt?: boolean, originator?: string, acceptDelayedBroadcast?: boolean);
    private queueOperationOnKey;
    private finishOperationOnKey;
    private getProtocol;
    private getOutputs;
    /**
     * Retrieves the value associated with a given key.
     *
     * @param {string} key - The key to retrieve the value for.
     * @param {string | undefined} [defaultValue=undefined] - The value to return if the key is not found.
     * @returns {Promise<string | undefined>} A promise that resolves to the value as a string,
     *   the defaultValue if the key is not found, or undefined if no defaultValue is provided.
     * @throws {Error} If too many outputs are found for the key (ambiguous state).
     * @throws {Error} If the found output's locking script cannot be decoded or represents an invalid token format.
     */
    get(key: string, defaultValue?: string | undefined): Promise<string | undefined>;
    private getLockingScript;
    private lookupValue;
    private getInputs;
    private getSpends;
    /**
     * Sets or updates the value associated with a given key atomically.
     * If the key already exists (one or more outputs found), it spends the existing output(s)
     * and creates a new one with the updated value. If multiple outputs exist for the key,
     * they are collapsed into a single new output.
     * If the key does not exist, it creates a new output.
     * Handles encryption if enabled.
     * If signing the update/collapse transaction fails, it relinquishes the original outputs and starts over with a new chain.
     * Ensures atomicity by locking the key during the operation, preventing concurrent updates
     * to the same key from missing earlier changes.
     *
     * @param {string} key - The key to set or update.
     * @param {string} value - The value to associate with the key.
     * @returns {Promise<OutpointString>} A promise that resolves to the outpoint string (txid.vout) of the new or updated token output.
     */
    set(key: string, value: string): Promise<OutpointString>;
    /**
     * Removes the key-value pair associated with the given key.
     * It finds the existing output(s) for the key and spends them without creating a new output.
     * If multiple outputs exist, they are all spent in the same transaction.
     * If the key does not exist, it does nothing.
     * If signing the removal transaction fails, it relinquishes the original outputs instead of spending.
     *
     * @param {string} key - The key to remove.
     * @returns {Promise<string[]>} A promise that resolves to the txids of the removal transactions if successful.
     */
    remove(key: string): Promise<string[]>;
}
//# sourceMappingURL=LocalKVStore.d.ts.map