"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CompletedProtoWallet = void 0;
//@ts-nocheck
const PrivateKey_js_1 = __importDefault(require("../../../primitives/PrivateKey.js"));
const index_js_1 = require("../../../wallet/index.js");
// Test Mock wallet which extends ProtoWallet but still implements Wallet interface
// Unsupported methods throw
class CompletedProtoWallet extends index_js_1.ProtoWallet {
    constructor(rootKeyOrKeyDeriver) {
        super(rootKeyOrKeyDeriver);
        if (rootKeyOrKeyDeriver instanceof index_js_1.KeyDeriver) {
            this.keyDeriver = rootKeyOrKeyDeriver;
        }
        else if (typeof rootKeyOrKeyDeriver === 'string' ||
            rootKeyOrKeyDeriver instanceof PrivateKey_js_1.default) {
            this.keyDeriver = new index_js_1.CachedKeyDeriver(rootKeyOrKeyDeriver);
        }
        else {
            throw new Error('Invalid key deriver provided');
        }
    }
    async isAuthenticated() {
        throw new Error('not implemented');
    }
    async waitForAuthentication() {
        throw new Error('not implemented');
    }
    async getNetwork() {
        throw new Error('not implemented');
    }
    async getVersion() {
        throw new Error('not implemented');
    }
    async getPublicKey(args) {
        if (args.privileged === true) {
            throw new Error('no privilege support');
        }
        if (args.identityKey === true) {
            if (this.keyDeriver === null || this.keyDeriver === undefined) {
                throw new Error('keyDeriver is not initialized');
            }
            return { publicKey: this.keyDeriver.rootKey.toPublicKey().toString() };
        }
        else {
            if (args.protocolID == null || typeof args.keyID !== 'string' || args.keyID.trim() === '') {
                throw new Error('protocolID and keyID are required if identityKey is false or undefined.');
            }
            if (this.keyDeriver === null || this.keyDeriver === undefined) {
                throw new Error('keyDeriver is not initialized');
            }
            return {
                publicKey: this.keyDeriver
                    .derivePublicKey(args.protocolID, args.keyID, typeof args.counterparty === 'string' && args.counterparty.trim() !== ''
                    ? args.counterparty
                    : 'self', Boolean(args.forSelf))
                    .toString()
            };
        }
    }
    async createAction() {
        throw new Error('not implemented');
    }
    async signAction() {
        throw new Error('not implemented');
    }
    async abortAction() {
        throw new Error('not implemented');
    }
    async listActions() {
        throw new Error('not implemented');
    }
    async internalizeAction() {
        throw new Error('not implemented');
    }
    async listOutputs() {
        throw new Error('not implemented');
    }
    async relinquishOutput() {
        throw new Error('not implemented');
    }
    async acquireCertificate() {
        throw new Error('not implemented');
    }
    async listCertificates() {
        throw new Error('not implemented');
    }
    async proveCertificate() {
        throw new Error('not implemented');
    }
    async relinquishCertificate() {
        throw new Error('not implemented');
    }
    async discoverByIdentityKey() {
        throw new Error('not implemented');
    }
    async discoverByAttributes() {
        throw new Error('not implemented');
    }
    async getHeight() {
        throw new Error('not implemented');
    }
    async getHeaderForHeight() {
        throw new Error('not implemented');
    }
}
exports.CompletedProtoWallet = CompletedProtoWallet;
//# sourceMappingURL=CompletedProtoWallet.js.map