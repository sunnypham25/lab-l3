"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TaskFailAbandoned = void 0;
const WalletMonitorTask_1 = require("./WalletMonitorTask");
/**
 * Handles transactions which do not have terminal status and have not been
 * updated for an extended time period.
 *
 * Calls `updateTransactionStatus` to set `status` to `failed`.
 * This returns inputs to spendable status and verifies that any
 * outputs are not spendable.
 */
class TaskFailAbandoned extends WalletMonitorTask_1.WalletMonitorTask {
    constructor(monitor, triggerMsecs = 1000 * 60 * 5) {
        super(monitor, TaskFailAbandoned.taskName);
        this.triggerMsecs = triggerMsecs;
    }
    trigger(nowMsecsSinceEpoch) {
        return {
            run: nowMsecsSinceEpoch > this.lastRunMsecsSinceEpoch + this.triggerMsecs
        };
    }
    async runTask() {
        let log = '';
        const limit = 100;
        let offset = 0;
        for (;;) {
            const now = new Date();
            const abandoned = new Date(now.getTime() - this.monitor.options.abandonedMsecs);
            const done = await this.storage.runAsStorageProvider(async (sp) => {
                const txsAll = await sp.findTransactions({
                    partial: {},
                    status: ['unprocessed', 'unsigned'],
                    paged: { limit, offset }
                });
                const txs = txsAll.filter(t => t.updated_at && t.updated_at < abandoned);
                for (const tx of txs) {
                    await sp.updateTransactionStatus('failed', tx.transactionId);
                    log += `updated tx ${tx.transactionId} status to 'failed'\n`;
                }
                return txs.length < limit;
            });
            if (done)
                break;
            offset += limit;
        }
        return log;
    }
}
exports.TaskFailAbandoned = TaskFailAbandoned;
TaskFailAbandoned.taskName = 'FailAbandoned';
//# sourceMappingURL=TaskFailAbandoned.js.map