import { Monitor } from '../Monitor';
import { WalletMonitorTask } from './WalletMonitorTask';
import { TableProvenTxReq } from '../../storage/schema/tables';
import { EntityProvenTxReq } from '../../storage/schema/entities';
/**
 * Setting provenTxReq status to 'unfail' when 'invalid' will attempt to find a merklePath, and if successful:
 *
 * 1. set the req status to 'unmined'
 * 2. set the referenced txs to 'unproven'
 * 3. determine if any inputs match user's existing outputs and if so update spentBy and spendable of those outputs.
 * 4. set the txs outputs to spendable
 *
 * If it fails (to find a merklePath), returns the req status to 'invalid'.
 */
export declare class TaskUnFail extends WalletMonitorTask {
    triggerMsecs: number;
    static taskName: string;
    /**
     * Set to true to trigger running this task
     */
    static checkNow: boolean;
    constructor(monitor: Monitor, triggerMsecs?: number);
    trigger(nowMsecsSinceEpoch: number): {
        run: boolean;
    };
    runTask(): Promise<string>;
    unfail(reqs: TableProvenTxReq[], indent?: number): Promise<{
        log: string;
    }>;
    /**
     * 2. set the referenced txs to 'unproven'
     * 3. determine if any inputs match user's existing outputs and if so update spentBy and spendable of those outputs.
     * 4. set the txs outputs to spendable
     *
     * @param req
     * @param indent
     * @returns
     */
    unfailReq(req: EntityProvenTxReq, indent: number): Promise<string>;
}
//# sourceMappingURL=TaskUnFail.d.ts.map