"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.aggregateActionResults = void 0;
const sdk_1 = require("@bsv/sdk");
const sdk_2 = require("../sdk");
const aggregateActionResults = async (storage, sendWithResultReqs, postToNetworkResult) => {
    const swr = [];
    const rar = [];
    for (const ar of sendWithResultReqs) {
        const txid = ar.txid;
        const d = postToNetworkResult.details.find(d => d.txid === txid);
        if (!d)
            throw new sdk_2.WERR_INTERNAL(`missing details for ${txid}`);
        const arNdr = { txid: d.txid, status: 'success', competingTxs: d.competingTxs };
        switch (d.status) {
            case 'success':
                // processing network has accepted this transaction
                ar.status = 'unproven';
                break;
            case 'doubleSpend':
                // confirmed double spend.
                ar.status = 'failed';
                arNdr.status = 'doubleSpend';
                if (d.competingTxs)
                    arNdr.competingBeef = await createMergedBeefOfTxids(d.competingTxs, storage);
                break;
            case 'serviceError':
                // services might improve
                ar.status = 'sending';
                arNdr.status = 'serviceError';
                break;
            case 'invalidTx':
                // nothing will fix this transaction
                ar.status = 'failed';
                arNdr.status = 'invalidTx';
                break;
            case 'unknown':
            case 'invalid':
            default:
                throw new sdk_2.WERR_INTERNAL(`processAction with notDelayed status ${d.status} should not occur.`);
        }
        swr.push({ txid, status: ar.status });
        rar.push(arNdr);
    }
    return { swr, rar };
};
exports.aggregateActionResults = aggregateActionResults;
async function createMergedBeefOfTxids(txids, storage) {
    const beef = new sdk_1.Beef();
    const options = {
        mergeToBeef: beef,
        ignoreNewProven: true
    };
    for (const txid of txids) {
        await storage.getBeefForTransaction(txid, options);
    }
    return beef.toBinary();
}
//# sourceMappingURL=aggregateResults.js.map