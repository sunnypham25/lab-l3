import { HexString, PubKeyHex, WalletNetwork } from '@bsv/sdk';
import { Beef, PrivateKey, PublicKey, Script, Transaction } from '@bsv/sdk';
import { Chain } from '../sdk/types';
import { CertOpsWallet } from '../sdk';
export declare function getIdentityKey(wallet: CertOpsWallet): Promise<PubKeyHex>;
export declare function toWalletNetwork(chain: Chain): WalletNetwork;
export declare function makeAtomicBeef(tx: Transaction, beef: number[] | Beef): number[];
/**
 * Coerce a bsv transaction encoded as a hex string, serialized array, or Transaction to Transaction
 * If tx is already a Transaction, just return it.
 * @publicbody
 */
export declare function asBsvSdkTx(tx: HexString | number[] | Transaction): Transaction;
/**
 * Coerce a bsv script encoded as a hex string, serialized array, or Script to Script
 * If script is already a Script, just return it.
 * @publicbody
 */
export declare function asBsvSdkScript(script: HexString | number[] | Script): Script;
/**
 * @param privKey bitcoin private key in 32 byte hex string form
 * @returns @bsv/sdk PrivateKey
 */
export declare function asBsvSdkPrivateKey(privKey: string): PrivateKey;
/**
 * @param pubKey bitcoin public key in standard compressed key hex string form
 * @returns @bsv/sdk PublicKey
 */
export declare function asBsvSdkPublickKey(pubKey: string): PublicKey;
/**
 * Helper function.
 *
 * Verifies that a possibly optional value has a value.
 */
export declare function verifyTruthy<T>(v: T | null | undefined, description?: string): T;
/**
 * Helper function.
 *
 * Verifies that a hex string is trimmed and lower case.
 */
export declare function verifyHexString(v: string): string;
/**
 * Helper function.
 *
 * Verifies that an optional or null hex string is undefined or a trimmed lowercase string.
 */
export declare function verifyOptionalHexString(v?: string | null): string | undefined;
/**
 * Helper function.
 *
 * Verifies that an optional or null number has a numeric value.
 */
export declare function verifyNumber(v: number | null | undefined): number;
/**
 * Helper function.
 *
 * Verifies that an optional or null number has a numeric value.
 */
export declare function verifyInteger(v: number | null | undefined): number;
/**
 * Helper function.
 *
 * Verifies that a database record identifier is an integer greater than zero.
 */
export declare function verifyId(id: number | undefined | null): number;
/**
 * Helper function.
 *
 * @throws WERR_BAD_REQUEST if results has length greater than one.
 *
 * @returns results[0] or undefined if length is zero.
 */
export declare function verifyOneOrNone<T>(results: T[]): T | undefined;
/**
 * Helper function.
 *
 * @throws WERR_BAD_REQUEST if results has length other than one.
 *
 * @returns results[0].
 */
export declare function verifyOne<T>(results: T[], errorDescrition?: string): T;
/**
 * Returns an await'able Promise that resolves in the given number of msecs.
 * @publicbody
 */
export declare function wait(msecs: number): Promise<void>;
/**
 * @returns count cryptographically secure random bytes as array of bytes
 */
export declare function randomBytes(count: number): number[];
/**
 * @returns count cryptographically secure random bytes as hex encoded string
 */
export declare function randomBytesHex(count: number): string;
/**
 * @returns count cryptographically secure random bytes as base64 encoded string
 */
export declare function randomBytesBase64(count: number): string;
export declare function validateSecondsSinceEpoch(time: number): Date;
/**
 * Compares lengths and direct equality of values.
 * @param arr1
 * @param arr2
 * @returns
 */
export declare function arraysEqual(arr1: Number[], arr2: Number[]): boolean;
export declare function optionalArraysEqual(arr1?: Number[], arr2?: Number[]): boolean;
export declare function maxDate(d1?: Date, d2?: Date): Date | undefined;
/**
 * Calculate the SHA256 hash of an array of bytes
 * @returns sha256 hash of buffer contents.
 * @publicbody
 */
export declare function sha256Hash(data: number[]): number[];
/**
 * Calculate the SHA256 hash of the SHA256 hash of an array of bytes.
 * @param data an array of bytes
 * @returns double sha256 hash of data, byte 0 of hash first.
 * @publicbody
 */
export declare function doubleSha256LE(data: number[]): number[];
/**
 * Calculate the SHA256 hash of the SHA256 hash of an array of bytes.
 * @param data is an array of bytes.
 * @returns reversed (big-endian) double sha256 hash of data, byte 31 of hash first.
 * @publicbody
 */
export declare function doubleSha256BE(data: number[]): number[];
//# sourceMappingURL=utilityHelpers.d.ts.map