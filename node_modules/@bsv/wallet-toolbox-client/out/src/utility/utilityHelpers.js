"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getIdentityKey = getIdentityKey;
exports.toWalletNetwork = toWalletNetwork;
exports.makeAtomicBeef = makeAtomicBeef;
exports.asBsvSdkTx = asBsvSdkTx;
exports.asBsvSdkScript = asBsvSdkScript;
exports.asBsvSdkPrivateKey = asBsvSdkPrivateKey;
exports.asBsvSdkPublickKey = asBsvSdkPublickKey;
exports.verifyTruthy = verifyTruthy;
exports.verifyHexString = verifyHexString;
exports.verifyOptionalHexString = verifyOptionalHexString;
exports.verifyNumber = verifyNumber;
exports.verifyInteger = verifyInteger;
exports.verifyId = verifyId;
exports.verifyOneOrNone = verifyOneOrNone;
exports.verifyOne = verifyOne;
exports.wait = wait;
exports.randomBytes = randomBytes;
exports.randomBytesHex = randomBytesHex;
exports.randomBytesBase64 = randomBytesBase64;
exports.validateSecondsSinceEpoch = validateSecondsSinceEpoch;
exports.arraysEqual = arraysEqual;
exports.optionalArraysEqual = optionalArraysEqual;
exports.maxDate = maxDate;
exports.sha256Hash = sha256Hash;
exports.doubleSha256LE = doubleSha256LE;
exports.doubleSha256BE = doubleSha256BE;
const sdk_1 = require("@bsv/sdk");
const index_client_1 = require("../index.client");
async function getIdentityKey(wallet) {
    return (await wallet.getPublicKey({ identityKey: true })).publicKey;
}
function toWalletNetwork(chain) {
    return chain === 'main' ? 'mainnet' : 'testnet';
}
function makeAtomicBeef(tx, beef) {
    if (Array.isArray(beef))
        beef = sdk_1.Beef.fromBinary(beef);
    beef.mergeTransaction(tx);
    return beef.toBinaryAtomic(tx.id('hex'));
}
/**
 * Coerce a bsv transaction encoded as a hex string, serialized array, or Transaction to Transaction
 * If tx is already a Transaction, just return it.
 * @publicbody
 */
function asBsvSdkTx(tx) {
    if (Array.isArray(tx)) {
        tx = sdk_1.Transaction.fromBinary(tx);
    }
    else if (typeof tx === 'string') {
        tx = sdk_1.Transaction.fromHex(tx);
    }
    return tx;
}
/**
 * Coerce a bsv script encoded as a hex string, serialized array, or Script to Script
 * If script is already a Script, just return it.
 * @publicbody
 */
function asBsvSdkScript(script) {
    if (Array.isArray(script)) {
        script = sdk_1.Script.fromBinary(script);
    }
    else if (typeof script === 'string') {
        script = sdk_1.Script.fromHex(script);
    }
    return script;
}
/**
 * @param privKey bitcoin private key in 32 byte hex string form
 * @returns @bsv/sdk PrivateKey
 */
function asBsvSdkPrivateKey(privKey) {
    return sdk_1.PrivateKey.fromString(privKey, 'hex');
}
/**
 * @param pubKey bitcoin public key in standard compressed key hex string form
 * @returns @bsv/sdk PublicKey
 */
function asBsvSdkPublickKey(pubKey) {
    return sdk_1.PublicKey.fromString(pubKey);
}
/**
 * Helper function.
 *
 * Verifies that a possibly optional value has a value.
 */
function verifyTruthy(v, description) {
    if (!v)
        throw new index_client_1.sdk.WERR_INTERNAL(description !== null && description !== void 0 ? description : 'A truthy value is required.');
    return v;
}
/**
 * Helper function.
 *
 * Verifies that a hex string is trimmed and lower case.
 */
function verifyHexString(v) {
    if (typeof v !== 'string')
        throw new index_client_1.sdk.WERR_INTERNAL('A string is required.');
    v = v.trim().toLowerCase();
    return v;
}
/**
 * Helper function.
 *
 * Verifies that an optional or null hex string is undefined or a trimmed lowercase string.
 */
function verifyOptionalHexString(v) {
    if (!v)
        return undefined;
    return verifyHexString(v);
}
/**
 * Helper function.
 *
 * Verifies that an optional or null number has a numeric value.
 */
function verifyNumber(v) {
    if (typeof v !== 'number')
        throw new index_client_1.sdk.WERR_INTERNAL('A number is required.');
    return v;
}
/**
 * Helper function.
 *
 * Verifies that an optional or null number has a numeric value.
 */
function verifyInteger(v) {
    if (typeof v !== 'number' || !Number.isInteger(v))
        throw new index_client_1.sdk.WERR_INTERNAL('An integer is required.');
    return v;
}
/**
 * Helper function.
 *
 * Verifies that a database record identifier is an integer greater than zero.
 */
function verifyId(id) {
    id = verifyInteger(id);
    if (id < 1)
        throw new index_client_1.sdk.WERR_INTERNAL(`id must be valid integer greater than zero.`);
    return id;
}
/**
 * Helper function.
 *
 * @throws WERR_BAD_REQUEST if results has length greater than one.
 *
 * @returns results[0] or undefined if length is zero.
 */
function verifyOneOrNone(results) {
    if (results.length > 1)
        throw new index_client_1.sdk.WERR_BAD_REQUEST('Result must be unique.');
    return results[0];
}
/**
 * Helper function.
 *
 * @throws WERR_BAD_REQUEST if results has length other than one.
 *
 * @returns results[0].
 */
function verifyOne(results, errorDescrition) {
    if (results.length !== 1)
        throw new index_client_1.sdk.WERR_BAD_REQUEST(errorDescrition !== null && errorDescrition !== void 0 ? errorDescrition : 'Result must exist and be unique.');
    return results[0];
}
/**
 * Returns an await'able Promise that resolves in the given number of msecs.
 * @publicbody
 */
function wait(msecs) {
    return new Promise(resolve => setTimeout(resolve, msecs));
}
/**
 * @returns count cryptographically secure random bytes as array of bytes
 */
function randomBytes(count) {
    return (0, sdk_1.Random)(count);
}
/**
 * @returns count cryptographically secure random bytes as hex encoded string
 */
function randomBytesHex(count) {
    return sdk_1.Utils.toHex((0, sdk_1.Random)(count));
}
/**
 * @returns count cryptographically secure random bytes as base64 encoded string
 */
function randomBytesBase64(count) {
    return sdk_1.Utils.toBase64((0, sdk_1.Random)(count));
}
function validateSecondsSinceEpoch(time) {
    const date = new Date(time * 1000);
    if (date.getTime() / 1000 !== time || time < 1600000000 || time > 100000000000) {
        throw new index_client_1.sdk.WERR_INVALID_PARAMETER('time', `valid "since epoch" unix time`);
    }
    return date;
}
/**
 * Compares lengths and direct equality of values.
 * @param arr1
 * @param arr2
 * @returns
 */
function arraysEqual(arr1, arr2) {
    if (arr1.length !== arr2.length)
        return false;
    for (let i = 0; i < arr1.length; i++) {
        if (arr1[i] !== arr2[i])
            return false;
    }
    return true;
}
function optionalArraysEqual(arr1, arr2) {
    if (!arr1 && !arr2)
        return true;
    if (!arr1 || !arr2)
        return false;
    return arraysEqual(arr1, arr2);
}
function maxDate(d1, d2) {
    if (d1 && d2) {
        if (d1 > d2)
            return d1;
        return d2;
    }
    if (d1)
        return d1;
    if (d2)
        return d2;
    return undefined;
}
/**
 * Calculate the SHA256 hash of an array of bytes
 * @returns sha256 hash of buffer contents.
 * @publicbody
 */
function sha256Hash(data) {
    const first = new sdk_1.Hash.SHA256().update(data).digest();
    return first;
}
/**
 * Calculate the SHA256 hash of the SHA256 hash of an array of bytes.
 * @param data an array of bytes
 * @returns double sha256 hash of data, byte 0 of hash first.
 * @publicbody
 */
function doubleSha256LE(data) {
    const first = new sdk_1.Hash.SHA256().update(data).digest();
    const second = new sdk_1.Hash.SHA256().update(first).digest();
    return second;
}
/**
 * Calculate the SHA256 hash of the SHA256 hash of an array of bytes.
 * @param data is an array of bytes.
 * @returns reversed (big-endian) double sha256 hash of data, byte 31 of hash first.
 * @publicbody
 */
function doubleSha256BE(data) {
    return doubleSha256LE(data).reverse();
}
//# sourceMappingURL=utilityHelpers.js.map