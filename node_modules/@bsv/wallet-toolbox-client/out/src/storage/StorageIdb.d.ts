import { IDBPDatabase, IDBPTransaction } from 'idb';
import { ListActionsResult, ListOutputsResult } from '@bsv/sdk';
import { TableCertificate, TableCertificateField, TableCertificateX, TableCommission, TableMonitorEvent, TableOutput, TableOutputBasket, TableOutputTag, TableOutputTagMap, TableProvenTx, TableProvenTxReq, TableSettings, TableSyncState, TableTransaction, TableTxLabel, TableTxLabelMap, TableUser } from './schema/tables';
import * as sdk from '../sdk/index';
import { StorageAdminStats, StorageProvider, StorageProviderOptions } from './StorageProvider';
import { StorageIdbSchema } from './schema/StorageIdbSchema';
import { DBType } from './StorageReader';
export interface StorageIdbOptions extends StorageProviderOptions {
}
/**
 * This class implements the `StorageProvider` interface using IndexedDB,
 * via the promises wrapper package `idb`.
 */
export declare class StorageIdb extends StorageProvider implements sdk.WalletStorageProvider {
    dbName: string;
    db?: IDBPDatabase<StorageIdbSchema>;
    constructor(options: StorageIdbOptions);
    /**
     * This method must be called at least once before any other method accesses the database,
     * and each time the schema may have updated.
     *
     * If the database has already been created in this context, `storageName` and `storageIdentityKey`
     * are ignored.
     *
     * @param storageName
     * @param storageIdentityKey
     * @returns
     */
    migrate(storageName: string, storageIdentityKey: string): Promise<string>;
    /**
     * Following initial database initialization, this method verfies that db is ready for use.
     *
     * @throws `WERR_INVALID_OPERATION` if the database has not been initialized by a call to `migrate`.
     *
     * @param storageName
     * @param storageIdentityKey
     *
     * @returns
     */
    verifyDB(storageName?: string, storageIdentityKey?: string): Promise<IDBPDatabase<StorageIdbSchema>>;
    /**
     * Convert the standard optional `TrxToken` parameter into either a direct knex database instance,
     * or a Knex.Transaction as appropriate.
     */
    toDbTrx(stores: string[], mode: 'readonly' | 'readwrite', trx?: sdk.TrxToken): IDBPTransaction<StorageIdbSchema, string[], 'readwrite' | 'readonly'>;
    /**
     * Called by `makeAvailable` to return storage `TableSettings`.
     * Since this is the first async method that must be called by all clients,
     * it is where async initialization occurs.
     *
     * After initialization, cached settings are returned.
     *
     * @param trx
     */
    readSettings(trx?: sdk.TrxToken): Promise<TableSettings>;
    initDB(storageName?: string, storageIdentityKey?: string): Promise<IDBPDatabase<StorageIdbSchema>>;
    reviewStatus(args: {
        agedLimit: Date;
        trx?: sdk.TrxToken;
    }): Promise<{
        log: string;
    }>;
    purgeData(params: sdk.PurgeParams, trx?: sdk.TrxToken): Promise<sdk.PurgeResults>;
    /**
     * Proceeds in three stages:
     * 1. Find an output that exactly funds the transaction (if exactSatoshis is not undefined).
     * 2. Find an output that overfunds by the least amount (targetSatoshis).
     * 3. Find an output that comes as close to funding as possible (targetSatoshis).
     * 4. Return undefined if no output is found.
     *
     * Outputs must belong to userId and basketId and have spendable true.
     * Their corresponding transaction must have status of 'completed', 'unproven', or 'sending' (if excludeSending is false).
     *
     * @param userId
     * @param basketId
     * @param targetSatoshis
     * @param exactSatoshis
     * @param excludeSending
     * @param transactionId
     * @returns next funding output to add to transaction or undefined if there are none.
     */
    allocateChangeInput(userId: number, basketId: number, targetSatoshis: number, exactSatoshis: number | undefined, excludeSending: boolean, transactionId: number): Promise<TableOutput | undefined>;
    getProvenOrRawTx(txid: string, trx?: sdk.TrxToken): Promise<sdk.ProvenOrRawTx>;
    getRawTxOfKnownValidTransaction(txid?: string, offset?: number, length?: number, trx?: sdk.TrxToken): Promise<number[] | undefined>;
    getLabelsForTransactionId(transactionId?: number, trx?: sdk.TrxToken): Promise<TableTxLabel[]>;
    getTagsForOutputId(outputId: number, trx?: sdk.TrxToken): Promise<TableOutputTag[]>;
    listActions(auth: sdk.AuthId, vargs: sdk.ValidListActionsArgs): Promise<ListActionsResult>;
    listOutputs(auth: sdk.AuthId, vargs: sdk.ValidListOutputsArgs): Promise<ListOutputsResult>;
    countChangeInputs(userId: number, basketId: number, excludeSending: boolean): Promise<number>;
    findCertificatesAuth(auth: sdk.AuthId, args: sdk.FindCertificatesArgs): Promise<TableCertificateX[]>;
    findOutputBasketsAuth(auth: sdk.AuthId, args: sdk.FindOutputBasketsArgs): Promise<TableOutputBasket[]>;
    findOutputsAuth(auth: sdk.AuthId, args: sdk.FindOutputsArgs): Promise<TableOutput[]>;
    insertCertificateAuth(auth: sdk.AuthId, certificate: TableCertificateX): Promise<number>;
    dropAllData(): Promise<void>;
    filterOutputTagMaps(args: sdk.FindOutputTagMapsArgs, filtered: (v: TableOutputTagMap) => void, userId?: number): Promise<void>;
    findOutputTagMaps(args: sdk.FindOutputTagMapsArgs): Promise<TableOutputTagMap[]>;
    filterProvenTxReqs(args: sdk.FindProvenTxReqsArgs, filtered: (v: TableProvenTxReq) => void, userId?: number): Promise<void>;
    findProvenTxReqs(args: sdk.FindProvenTxReqsArgs): Promise<TableProvenTxReq[]>;
    filterProvenTxs(args: sdk.FindProvenTxsArgs, filtered: (v: TableProvenTx) => void, userId?: number): Promise<void>;
    findProvenTxs(args: sdk.FindProvenTxsArgs): Promise<TableProvenTx[]>;
    filterTxLabelMaps(args: sdk.FindTxLabelMapsArgs, filtered: (v: TableTxLabelMap) => void, userId?: number): Promise<void>;
    findTxLabelMaps(args: sdk.FindTxLabelMapsArgs): Promise<TableTxLabelMap[]>;
    countOutputTagMaps(args: sdk.FindOutputTagMapsArgs): Promise<number>;
    countProvenTxReqs(args: sdk.FindProvenTxReqsArgs): Promise<number>;
    countProvenTxs(args: sdk.FindProvenTxsArgs): Promise<number>;
    countTxLabelMaps(args: sdk.FindTxLabelMapsArgs): Promise<number>;
    insertCertificate(certificate: TableCertificateX, trx?: sdk.TrxToken): Promise<number>;
    insertCertificateField(certificateField: TableCertificateField, trx?: sdk.TrxToken): Promise<void>;
    insertCommission(commission: TableCommission, trx?: sdk.TrxToken): Promise<number>;
    insertMonitorEvent(event: TableMonitorEvent, trx?: sdk.TrxToken): Promise<number>;
    insertOutput(output: TableOutput, trx?: sdk.TrxToken): Promise<number>;
    insertOutputBasket(basket: TableOutputBasket, trx?: sdk.TrxToken): Promise<number>;
    insertOutputTag(tag: TableOutputTag, trx?: sdk.TrxToken): Promise<number>;
    insertOutputTagMap(tagMap: TableOutputTagMap, trx?: sdk.TrxToken): Promise<void>;
    insertProvenTx(tx: TableProvenTx, trx?: sdk.TrxToken): Promise<number>;
    insertProvenTxReq(tx: TableProvenTxReq, trx?: sdk.TrxToken): Promise<number>;
    insertSyncState(syncState: TableSyncState, trx?: sdk.TrxToken): Promise<number>;
    insertTransaction(tx: TableTransaction, trx?: sdk.TrxToken): Promise<number>;
    insertTxLabel(label: TableTxLabel, trx?: sdk.TrxToken): Promise<number>;
    insertTxLabelMap(labelMap: TableTxLabelMap, trx?: sdk.TrxToken): Promise<void>;
    insertUser(user: TableUser, trx?: sdk.TrxToken): Promise<number>;
    updateIdb<T>(id: number | number[], update: Partial<T>, keyProp: string, storeName: string, trx?: sdk.TrxToken): Promise<number>;
    updateIdbKey<T>(key: (number | string)[], update: Partial<T>, keyProps: string[], storeName: string, trx?: sdk.TrxToken): Promise<number>;
    updateCertificate(id: number, update: Partial<TableCertificate>, trx?: sdk.TrxToken): Promise<number>;
    updateCertificateField(certificateId: number, fieldName: string, update: Partial<TableCertificateField>, trx?: sdk.TrxToken): Promise<number>;
    updateCommission(id: number, update: Partial<TableCommission>, trx?: sdk.TrxToken): Promise<number>;
    updateMonitorEvent(id: number, update: Partial<TableMonitorEvent>, trx?: sdk.TrxToken): Promise<number>;
    updateOutput(id: number, update: Partial<TableOutput>, trx?: sdk.TrxToken): Promise<number>;
    updateOutputBasket(id: number, update: Partial<TableOutputBasket>, trx?: sdk.TrxToken): Promise<number>;
    updateOutputTag(id: number, update: Partial<TableOutputTag>, trx?: sdk.TrxToken): Promise<number>;
    updateProvenTx(id: number, update: Partial<TableProvenTx>, trx?: sdk.TrxToken): Promise<number>;
    updateProvenTxReq(id: number | number[], update: Partial<TableProvenTxReq>, trx?: sdk.TrxToken): Promise<number>;
    updateSyncState(id: number, update: Partial<TableSyncState>, trx?: sdk.TrxToken): Promise<number>;
    updateTransaction(id: number | number[], update: Partial<TableTransaction>, trx?: sdk.TrxToken): Promise<number>;
    updateTxLabel(id: number, update: Partial<TableTxLabel>, trx?: sdk.TrxToken): Promise<number>;
    updateUser(id: number, update: Partial<TableUser>, trx?: sdk.TrxToken): Promise<number>;
    updateOutputTagMap(outputId: number, tagId: number, update: Partial<TableOutputTagMap>, trx?: sdk.TrxToken): Promise<number>;
    updateTxLabelMap(transactionId: number, txLabelId: number, update: Partial<TableTxLabelMap>, trx?: sdk.TrxToken): Promise<number>;
    destroy(): Promise<void>;
    allStores: string[];
    /**
     * @param scope
     * @param trx
     * @returns
     */
    transaction<T>(scope: (trx: sdk.TrxToken) => Promise<T>, trx?: sdk.TrxToken): Promise<T>;
    filterCertificateFields(args: sdk.FindCertificateFieldsArgs, filtered: (v: TableCertificateField) => void): Promise<void>;
    findCertificateFields(args: sdk.FindCertificateFieldsArgs): Promise<TableCertificateField[]>;
    filterCertificates(args: sdk.FindCertificatesArgs, filtered: (v: TableCertificateX) => void): Promise<void>;
    findCertificates(args: sdk.FindCertificatesArgs): Promise<TableCertificateX[]>;
    filterCommissions(args: sdk.FindCommissionsArgs, filtered: (v: TableCommission) => void): Promise<void>;
    findCommissions(args: sdk.FindCommissionsArgs): Promise<TableCommission[]>;
    filterMonitorEvents(args: sdk.FindMonitorEventsArgs, filtered: (v: TableMonitorEvent) => void): Promise<void>;
    findMonitorEvents(args: sdk.FindMonitorEventsArgs): Promise<TableMonitorEvent[]>;
    filterOutputBaskets(args: sdk.FindOutputBasketsArgs, filtered: (v: TableOutputBasket) => void): Promise<void>;
    findOutputBaskets(args: sdk.FindOutputBasketsArgs): Promise<TableOutputBasket[]>;
    filterOutputs(args: sdk.FindOutputsArgs, filtered: (v: TableOutput) => void, tagIds?: number[], isQueryModeAll?: boolean): Promise<void>;
    findOutputs(args: sdk.FindOutputsArgs, tagIds?: number[], isQueryModeAll?: boolean): Promise<TableOutput[]>;
    filterOutputTags(args: sdk.FindOutputTagsArgs, filtered: (v: TableOutputTag) => void): Promise<void>;
    findOutputTags(args: sdk.FindOutputTagsArgs): Promise<TableOutputTag[]>;
    filterSyncStates(args: sdk.FindSyncStatesArgs, filtered: (v: TableSyncState) => void): Promise<void>;
    findSyncStates(args: sdk.FindSyncStatesArgs): Promise<TableSyncState[]>;
    filterTransactions(args: sdk.FindTransactionsArgs, filtered: (v: TableTransaction) => void, labelIds?: number[], isQueryModeAll?: boolean): Promise<void>;
    findTransactions(args: sdk.FindTransactionsArgs, labelIds?: number[], isQueryModeAll?: boolean): Promise<TableTransaction[]>;
    filterTxLabels(args: sdk.FindTxLabelsArgs, filtered: (v: TableTxLabel) => void): Promise<void>;
    findTxLabels(args: sdk.FindTxLabelsArgs): Promise<TableTxLabel[]>;
    filterUsers(args: sdk.FindUsersArgs, filtered: (v: TableUser) => void): Promise<void>;
    findUsers(args: sdk.FindUsersArgs): Promise<TableUser[]>;
    countCertificateFields(args: sdk.FindCertificateFieldsArgs): Promise<number>;
    countCertificates(args: sdk.FindCertificatesArgs): Promise<number>;
    countCommissions(args: sdk.FindCommissionsArgs): Promise<number>;
    countMonitorEvents(args: sdk.FindMonitorEventsArgs): Promise<number>;
    countOutputBaskets(args: sdk.FindOutputBasketsArgs): Promise<number>;
    countOutputs(args: sdk.FindOutputsArgs, tagIds?: number[], isQueryModeAll?: boolean): Promise<number>;
    countOutputTags(args: sdk.FindOutputTagsArgs): Promise<number>;
    countSyncStates(args: sdk.FindSyncStatesArgs): Promise<number>;
    countTransactions(args: sdk.FindTransactionsArgs, labelIds?: number[], isQueryModeAll?: boolean): Promise<number>;
    countTxLabels(args: sdk.FindTxLabelsArgs): Promise<number>;
    countUsers(args: sdk.FindUsersArgs): Promise<number>;
    getProvenTxsForUser(args: sdk.FindForUserSincePagedArgs): Promise<TableProvenTx[]>;
    getProvenTxReqsForUser(args: sdk.FindForUserSincePagedArgs): Promise<TableProvenTxReq[]>;
    getTxLabelMapsForUser(args: sdk.FindForUserSincePagedArgs): Promise<TableTxLabelMap[]>;
    getOutputTagMapsForUser(args: sdk.FindForUserSincePagedArgs): Promise<TableOutputTagMap[]>;
    verifyReadyForDatabaseAccess(trx?: sdk.TrxToken): Promise<DBType>;
    /**
     * Helper to force uniform behavior across database engines.
     * Use to process all individual records with time stamps or number[] retreived from database.
     */
    validateEntity<T extends sdk.EntityTimeStamp>(entity: T, dateFields?: string[], booleanFields?: string[]): T;
    /**
     * Helper to force uniform behavior across database engines.
     * Use to process all arrays of records with time stamps retreived from database.
     * @returns input `entities` array with contained values validated.
     */
    validateEntities<T extends sdk.EntityTimeStamp>(entities: T[], dateFields?: string[], booleanFields?: string[]): T[];
    /**
     * Helper to force uniform behavior across database engines.
     * Use to process the update template for entities being updated.
     */
    validatePartialForUpdate<T extends sdk.EntityTimeStamp>(update: Partial<T>, dateFields?: string[], booleanFields?: string[]): Partial<T>;
    /**
     * Helper to force uniform behavior across database engines.
     * Use to process new entities being inserted into the database.
     */
    validateEntityForInsert<T extends sdk.EntityTimeStamp>(entity: T, trx?: sdk.TrxToken, dateFields?: string[], booleanFields?: string[]): Promise<any>;
    validateRawTransaction(t: TableTransaction, trx?: sdk.TrxToken): Promise<void>;
    adminStats(adminIdentityKey: string): Promise<StorageAdminStats>;
}
//# sourceMappingURL=StorageIdb.d.ts.map