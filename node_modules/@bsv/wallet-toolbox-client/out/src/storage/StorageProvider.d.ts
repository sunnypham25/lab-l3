import { AbortActionResult, Beef, InternalizeActionArgs, ListActionsResult, ListOutputsResult, PubKeyHex, ListCertificatesResult, TrustSelf, RelinquishCertificateArgs, RelinquishOutputArgs, AbortActionArgs } from '@bsv/sdk';
import { sdk, TableCertificateX, TableMonitorEvent, TableOutput, TableOutputBasket, TableOutputTag, TableOutputX, TableProvenTxReq, TableProvenTxReqDynamics, TableTxLabel } from '../index.client';
import { GetReqsAndBeefResult } from './methods/processAction';
import { PostReqsToNetworkResult } from './methods/attemptToPostReqsToNetwork';
import { StorageReaderWriter, StorageReaderWriterOptions } from './StorageReaderWriter';
import { EntityProvenTxReq } from './schema/entities';
import { ServicesCallHistory } from '../sdk/WalletServices.interfaces';
export declare abstract class StorageProvider extends StorageReaderWriter implements sdk.WalletStorageProvider {
    isDirty: boolean;
    _services?: sdk.WalletServices;
    feeModel: sdk.StorageFeeModel;
    commissionSatoshis: number;
    commissionPubKeyHex?: PubKeyHex;
    maxRecursionDepth?: number;
    static defaultOptions(): {
        feeModel: sdk.StorageFeeModel;
        commissionSatoshis: number;
        commissionPubKeyHex: undefined;
    };
    static createStorageBaseOptions(chain: sdk.Chain): StorageProviderOptions;
    constructor(options: StorageProviderOptions);
    abstract reviewStatus(args: {
        agedLimit: Date;
        trx?: sdk.TrxToken;
    }): Promise<{
        log: string;
    }>;
    abstract purgeData(params: sdk.PurgeParams, trx?: sdk.TrxToken): Promise<sdk.PurgeResults>;
    abstract allocateChangeInput(userId: number, basketId: number, targetSatoshis: number, exactSatoshis: number | undefined, excludeSending: boolean, transactionId: number): Promise<TableOutput | undefined>;
    abstract getProvenOrRawTx(txid: string, trx?: sdk.TrxToken): Promise<sdk.ProvenOrRawTx>;
    abstract getRawTxOfKnownValidTransaction(txid?: string, offset?: number, length?: number, trx?: sdk.TrxToken): Promise<number[] | undefined>;
    abstract getLabelsForTransactionId(transactionId?: number, trx?: sdk.TrxToken): Promise<TableTxLabel[]>;
    abstract getTagsForOutputId(outputId: number, trx?: sdk.TrxToken): Promise<TableOutputTag[]>;
    abstract listActions(auth: sdk.AuthId, args: sdk.ValidListActionsArgs): Promise<ListActionsResult>;
    abstract listOutputs(auth: sdk.AuthId, args: sdk.ValidListOutputsArgs): Promise<ListOutputsResult>;
    abstract countChangeInputs(userId: number, basketId: number, excludeSending: boolean): Promise<number>;
    abstract findCertificatesAuth(auth: sdk.AuthId, args: sdk.FindCertificatesArgs): Promise<TableCertificateX[]>;
    abstract findOutputBasketsAuth(auth: sdk.AuthId, args: sdk.FindOutputBasketsArgs): Promise<TableOutputBasket[]>;
    abstract findOutputsAuth(auth: sdk.AuthId, args: sdk.FindOutputsArgs): Promise<TableOutput[]>;
    abstract insertCertificateAuth(auth: sdk.AuthId, certificate: TableCertificateX): Promise<number>;
    abstract adminStats(adminIdentityKey: string): Promise<AdminStatsResult>;
    isStorageProvider(): boolean;
    setServices(v: sdk.WalletServices): void;
    getServices(): sdk.WalletServices;
    abortAction(auth: sdk.AuthId, args: AbortActionArgs): Promise<AbortActionResult>;
    internalizeAction(auth: sdk.AuthId, args: InternalizeActionArgs): Promise<sdk.StorageInternalizeActionResult>;
    /**
     * Given an array of transaction txids with current ProvenTxReq ready-to-share status,
     * lookup their ProvenTxReqApi req records.
     * For the txids with reqs and status still ready to send construct a single merged beef.
     *
     * @param txids
     * @param knownTxids
     * @param trx
     */
    getReqsAndBeefToShareWithWorld(txids: string[], knownTxids: string[], trx?: sdk.TrxToken): Promise<GetReqsAndBeefResult>;
    mergeReqToBeefToShareExternally(req: TableProvenTxReq, mergeToBeef: Beef, knownTxids: string[], trx?: sdk.TrxToken): Promise<void>;
    /**
     * Checks if txid is a known valid ProvenTx and returns it if found.
     * Next checks if txid is a current ProvenTxReq and returns that if found.
     * If `newReq` is provided and an existing ProvenTxReq isn't found,
     * use `newReq` to create a new ProvenTxReq.
     *
     * This is safe "findOrInsert" operation using retry if unique index constraint
     * is violated by a race condition insert.
     *
     * @param txid
     * @param newReq
     * @param trx
     * @returns
     */
    getProvenOrReq(txid: string, newReq?: TableProvenTxReq, trx?: sdk.TrxToken): Promise<sdk.StorageProvenOrReq>;
    updateTransactionsStatus(transactionIds: number[], status: sdk.TransactionStatus, trx?: sdk.TrxToken): Promise<void>;
    /**
     * For all `status` values besides 'failed', just updates the transaction records status property.
     *
     * For 'status' of 'failed', attempts to make outputs previously allocated as inputs to this transaction usable again.
     *
     * @param status
     * @param transactionId
     * @param userId
     * @param reference
     * @param trx
     */
    updateTransactionStatus(status: sdk.TransactionStatus, transactionId?: number, userId?: number, reference?: string, trx?: sdk.TrxToken): Promise<void>;
    createAction(auth: sdk.AuthId, args: sdk.ValidCreateActionArgs): Promise<sdk.StorageCreateActionResult>;
    processAction(auth: sdk.AuthId, args: sdk.StorageProcessActionArgs): Promise<sdk.StorageProcessActionResults>;
    attemptToPostReqsToNetwork(reqs: EntityProvenTxReq[], trx?: sdk.TrxToken): Promise<PostReqsToNetworkResult>;
    listCertificates(auth: sdk.AuthId, args: sdk.ValidListCertificatesArgs): Promise<ListCertificatesResult>;
    verifyKnownValidTransaction(txid: string, trx?: sdk.TrxToken): Promise<boolean>;
    getValidBeefForKnownTxid(txid: string, mergeToBeef?: Beef, trustSelf?: TrustSelf, knownTxids?: string[], trx?: sdk.TrxToken, requiredLevels?: number): Promise<Beef>;
    getValidBeefForTxid(txid: string, mergeToBeef?: Beef, trustSelf?: TrustSelf, knownTxids?: string[], trx?: sdk.TrxToken, requiredLevels?: number): Promise<Beef | undefined>;
    getBeefForTransaction(txid: string, options: sdk.StorageGetBeefOptions): Promise<Beef>;
    findMonitorEventById(id: number, trx?: sdk.TrxToken): Promise<TableMonitorEvent | undefined>;
    relinquishCertificate(auth: sdk.AuthId, args: RelinquishCertificateArgs): Promise<number>;
    relinquishOutput(auth: sdk.AuthId, args: RelinquishOutputArgs): Promise<number>;
    processSyncChunk(args: sdk.RequestSyncChunkArgs, chunk: sdk.SyncChunk): Promise<sdk.ProcessSyncChunkResult>;
    /**
     * Handles storage changes when a valid MerklePath and mined block header are found for a ProvenTxReq txid.
     *
     * Performs the following storage updates (typically):
     * 1. Lookup the exising `ProvenTxReq` record for its rawTx
     * 2. Insert a new ProvenTx record using properties from `args` and rawTx, yielding a new provenTxId
     * 3. Update ProvenTxReq record with status 'completed' and new provenTxId value (and history of status changed)
     * 4. Unpack notify transactionIds from req and update each transaction's status to 'completed', provenTxId value.
     * 5. Update ProvenTxReq history again to record that transactions have been notified.
     * 6. Return results...
     *
     * Alterations of "typically" to handle:
     */
    updateProvenTxReqWithNewProvenTx(args: sdk.UpdateProvenTxReqWithNewProvenTxArgs): Promise<sdk.UpdateProvenTxReqWithNewProvenTxResult>;
    /**
     * For each spendable output in the 'default' basket of the authenticated user,
     * verify that the output script, satoshis, vout and txid match that of an output
     * still in the mempool of at least one service provider.
     *
     * @returns object with invalidSpendableOutputs array. A good result is an empty array.
     */
    confirmSpendableOutputs(): Promise<{
        invalidSpendableOutputs: TableOutput[];
    }>;
    updateProvenTxReqDynamics(id: number, update: Partial<TableProvenTxReqDynamics>, trx?: sdk.TrxToken): Promise<number>;
    extendOutput(o: TableOutput, includeBasket?: boolean, includeTags?: boolean, trx?: sdk.TrxToken): Promise<TableOutputX>;
    validateOutputScript(o: TableOutput, trx?: sdk.TrxToken): Promise<void>;
}
export interface StorageProviderOptions extends StorageReaderWriterOptions {
    chain: sdk.Chain;
    feeModel: sdk.StorageFeeModel;
    /**
     * Transactions created by this Storage can charge a fee per transaction.
     * A value of zero disables commission fees.
     */
    commissionSatoshis: number;
    /**
     * If commissionSatoshis is greater than zero, must be a valid public key hex string.
     * The actual locking script for each commission will use a public key derived
     * from this key by information stored in the commissions table.
     */
    commissionPubKeyHex?: PubKeyHex;
}
export declare function validateStorageFeeModel(v?: sdk.StorageFeeModel): sdk.StorageFeeModel;
export interface StorageAdminStats {
    requestedBy: string;
    when: string;
    usersDay: number;
    usersWeek: number;
    usersMonth: number;
    usersTotal: number;
    transactionsDay: number;
    transactionsWeek: number;
    transactionsMonth: number;
    transactionsTotal: number;
    txCompletedDay: number;
    txCompletedWeek: number;
    txCompletedMonth: number;
    txCompletedTotal: number;
    txFailedDay: number;
    txFailedWeek: number;
    txFailedMonth: number;
    txFailedTotal: number;
    txUnprocessedDay: number;
    txUnprocessedWeek: number;
    txUnprocessedMonth: number;
    txUnprocessedTotal: number;
    txSendingDay: number;
    txSendingWeek: number;
    txSendingMonth: number;
    txSendingTotal: number;
    txUnprovenDay: number;
    txUnprovenWeek: number;
    txUnprovenMonth: number;
    txUnprovenTotal: number;
    txUnsignedDay: number;
    txUnsignedWeek: number;
    txUnsignedMonth: number;
    txUnsignedTotal: number;
    txNosendDay: number;
    txNosendWeek: number;
    txNosendMonth: number;
    txNosendTotal: number;
    txNonfinalDay: number;
    txNonfinalWeek: number;
    txNonfinalMonth: number;
    txNonfinalTotal: number;
    txUnfailDay: number;
    txUnfailWeek: number;
    txUnfailMonth: number;
    txUnfailTotal: number;
    satoshisDefaultDay: number;
    satoshisDefaultWeek: number;
    satoshisDefaultMonth: number;
    satoshisDefaultTotal: number;
    satoshisOtherDay: number;
    satoshisOtherWeek: number;
    satoshisOtherMonth: number;
    satoshisOtherTotal: number;
    basketsDay: number;
    basketsWeek: number;
    basketsMonth: number;
    basketsTotal: number;
    labelsDay: number;
    labelsWeek: number;
    labelsMonth: number;
    labelsTotal: number;
    tagsDay: number;
    tagsWeek: number;
    tagsMonth: number;
    tagsTotal: number;
}
export interface AdminStatsResult extends StorageAdminStats {
    servicesStats?: ServicesCallHistory;
    monitorStats?: ServicesCallHistory;
}
//# sourceMappingURL=StorageProvider.d.ts.map