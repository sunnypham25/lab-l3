"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.reviewStatusIdb = reviewStatusIdb;
/**
 * Looks for unpropagated state:
 *
 * 1. set transactions to 'failed' if not already failed and provenTxReq with matching txid has status of 'invalid'.
 * 2. sets transactions to 'completed' if provenTx with matching txid exists and current provenTxId is null.
 * 3. sets outputs to spendable true, spentBy undefined if spentBy is a transaction with status 'failed'.
 *
 * @param storage
 * @param args
 * @returns
 */
async function reviewStatusIdb(storage, args) {
    const r = { log: '' };
    // 1. set transactions to 'failed' if not already failed and provenTxReq with matching txid has status of 'invalid'.
    const invalidTxids = [];
    await storage.filterProvenTxReqs({ partial: { status: 'invalid' } }, txReq => {
        invalidTxids.push(txReq.txid);
    });
    for (const txid of invalidTxids) {
        const txs = await storage.findTransactions({ partial: { txid } });
        for (const tx of txs) {
            if (tx.status !== 'failed') {
                r.log += `transaction ${tx.transactionId} updated to status of 'failed' was ${tx.status}\n`;
                await storage.updateTransactionStatus('failed', tx.transactionId);
            }
        }
    }
    // 2. sets transactions to 'completed' if provenTx with matching txid exists and current provenTxId is null.
    // 3. sets outputs to spendable true, spentBy undefined if spentBy is a transaction with status 'failed'.
    return r;
}
//# sourceMappingURL=reviewStatusIdb.js.map