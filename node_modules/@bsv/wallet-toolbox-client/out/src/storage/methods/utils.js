"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.varUintSize = varUintSize;
exports.transactionInputSize = transactionInputSize;
exports.transactionOutputSize = transactionOutputSize;
exports.transactionSize = transactionSize;
const index_client_1 = require("../../index.client");
/**
 * Returns the byte size required to encode number as Bitcoin VarUint
 * @publicbody
 */
function varUintSize(val) {
    if (val < 0)
        throw new index_client_1.sdk.WERR_INVALID_PARAMETER('varUint', 'non-negative');
    return val <= 0xfc ? 1 : val <= 0xffff ? 3 : val <= 0xffffffff ? 5 : 9;
}
/**
 * @param scriptSize byte length of input script
 * @returns serialized byte length a transaction input
 */
function transactionInputSize(scriptSize) {
    return (32 + // txid
        4 + // vout
        varUintSize(scriptSize) + // script length, this is already in bytes
        scriptSize + // script
        4); // sequence number
}
/**
 * @param scriptSize byte length of output script
 * @returns serialized byte length a transaction output
 */
function transactionOutputSize(scriptSize) {
    return (varUintSize(scriptSize) + // output script length, from script encoded as hex string
        scriptSize + // output script
        8); // output amount (satoshis)
}
/**
 * Compute the serialized binary transaction size in bytes
 * given the number of inputs and outputs,
 * and the size of each script.
 * @param inputs array of input script lengths, in bytes
 * @param outputs array of output script lengths, in bytes
 * @returns total transaction size in bytes
 */
function transactionSize(inputs, outputs) {
    return (4 + // Version
        varUintSize(inputs.length) + // Number of inputs
        inputs.reduce((a, e) => a + transactionInputSize(e), 0) + // all inputs
        varUintSize(outputs.length) + // Number of outputs
        outputs.reduce((a, e) => a + transactionOutputSize(e), 0) + // all outputs
        4); // lock time
}
//# sourceMappingURL=utils.js.map