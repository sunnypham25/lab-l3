"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.listActionsIdb = listActionsIdb;
const sdk_1 = require("@bsv/sdk");
const index_client_1 = require("../../index.client");
const sdk_2 = require("../../sdk");
const ListActionsSpecOp_1 = require("./ListActionsSpecOp");
async function listActionsIdb(storage, auth, vargs) {
    const limit = vargs.limit;
    const offset = vargs.offset;
    const r = {
        totalActions: 0,
        actions: []
    };
    let specOp = undefined;
    let specOpLabels = [];
    let labels = [];
    for (const label of vargs.labels) {
        if ((0, sdk_2.isListActionsSpecOp)(label)) {
            specOp = (0, ListActionsSpecOp_1.getLabelToSpecOp)()[label];
        }
        else {
            labels.push(label);
        }
    }
    if ((specOp === null || specOp === void 0 ? void 0 : specOp.labelsToIntercept) !== undefined) {
        const intercept = specOp.labelsToIntercept;
        const labels2 = labels;
        labels = [];
        if (intercept.length === 0) {
            specOpLabels = labels2;
        }
        for (const label of labels2) {
            if (intercept.indexOf(label) >= 0) {
                specOpLabels.push(label);
            }
            else {
                labels.push(label);
            }
        }
    }
    let labelIds = [];
    if (labels.length > 0) {
        await storage.filterTxLabels({ partial: { userId: auth.userId, isDeleted: false } }, tl => {
            if (labels.includes(tl.label)) {
                labelIds.push(tl.txLabelId);
            }
        });
    }
    const isQueryModeAll = vargs.labelQueryMode === 'all';
    if (isQueryModeAll && labelIds.length < labels.length)
        // all the required labels don't exist, impossible to satisfy.
        return r;
    if (!isQueryModeAll && labelIds.length === 0 && labels.length > 0)
        // any and only non-existing labels, impossible to satisfy.
        return r;
    const stati = (specOp === null || specOp === void 0 ? void 0 : specOp.setStatusFilter)
        ? specOp.setStatusFilter()
        : ['completed', 'unprocessed', 'sending', 'unproven', 'unsigned', 'nosend', 'nonfinal'];
    const noLabels = labelIds.length === 0;
    const txs = await storage.findTransactions({
        partial: { userId: auth.userId },
        status: stati,
        paged: { limit: vargs.limit, offset: vargs.offset },
        noRawTx: true
    }, labelIds, isQueryModeAll);
    if (txs.length === vargs.limit) {
        r.totalActions = await storage.countTransactions({ partial: { userId: auth.userId }, status: stati }, labelIds, isQueryModeAll);
    }
    else {
        r.totalActions = txs.length;
    }
    if (specOp === null || specOp === void 0 ? void 0 : specOp.postProcess) {
        await specOp.postProcess(storage, auth, vargs, specOpLabels, txs);
    }
    for (const tx of txs) {
        const wtx = {
            txid: tx.txid || '',
            satoshis: tx.satoshis || 0,
            status: tx.status,
            isOutgoing: !!tx.isOutgoing,
            description: tx.description || '',
            version: tx.version || 0,
            lockTime: tx.lockTime || 0
        };
        r.actions.push(wtx);
    }
    if (vargs.includeLabels || vargs.includeInputs || vargs.includeOutputs) {
        await Promise.all(txs.map(async (tx, i) => {
            var _a, _b, _c;
            //let i = -1
            //for (const tx of txs) {
            //    i++
            const action = r.actions[i];
            if (vargs.includeLabels) {
                action.labels = (await storage.getLabelsForTransactionId(tx.transactionId)).map(l => l.label);
            }
            if (vargs.includeOutputs) {
                const outputs = await storage.findOutputs({
                    partial: { transactionId: tx.transactionId },
                    noScript: !vargs.includeOutputLockingScripts
                });
                action.outputs = [];
                for (const o of outputs) {
                    await storage.extendOutput(o, true, true);
                    const wo = {
                        satoshis: o.satoshis || 0,
                        spendable: !!o.spendable,
                        tags: ((_a = o.tags) === null || _a === void 0 ? void 0 : _a.map(t => t.tag)) || [],
                        outputIndex: Number(o.vout),
                        outputDescription: o.outputDescription || '',
                        basket: ((_b = o.basket) === null || _b === void 0 ? void 0 : _b.name) || ''
                    };
                    if (vargs.includeOutputLockingScripts)
                        wo.lockingScript = (0, index_client_1.asString)(o.lockingScript || []);
                    action.outputs.push(wo);
                }
            }
            if (vargs.includeInputs) {
                const inputs = await storage.findOutputs({
                    partial: { spentBy: tx.transactionId },
                    noScript: !vargs.includeInputSourceLockingScripts
                });
                action.inputs = [];
                if (inputs.length > 0) {
                    const rawTx = await storage.getRawTxOfKnownValidTransaction(tx.txid);
                    let bsvTx = undefined;
                    if (rawTx) {
                        bsvTx = sdk_1.Transaction.fromBinary(rawTx);
                    }
                    for (const o of inputs) {
                        await storage.extendOutput(o, true, true);
                        const input = bsvTx === null || bsvTx === void 0 ? void 0 : bsvTx.inputs.find(v => v.sourceTXID === o.txid && v.sourceOutputIndex === o.vout);
                        const wo = {
                            sourceOutpoint: `${o.txid}.${o.vout}`,
                            sourceSatoshis: o.satoshis || 0,
                            inputDescription: o.outputDescription || '',
                            sequenceNumber: (input === null || input === void 0 ? void 0 : input.sequence) || 0
                        };
                        action.inputs.push(wo);
                        if (vargs.includeInputSourceLockingScripts) {
                            wo.sourceLockingScript = (0, index_client_1.asString)(o.lockingScript || []);
                        }
                        if (vargs.includeInputUnlockingScripts) {
                            wo.unlockingScript = (_c = input === null || input === void 0 ? void 0 : input.unlockingScript) === null || _c === void 0 ? void 0 : _c.toHex();
                        }
                    }
                }
            }
            //}
        }));
    }
    return r;
}
//# sourceMappingURL=listActionsIdb.js.map