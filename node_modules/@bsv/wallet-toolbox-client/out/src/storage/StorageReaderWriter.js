"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StorageReaderWriter = void 0;
const utilityHelpers_1 = require("../utility/utilityHelpers");
const entities_1 = require("./schema/entities");
const StorageReader_1 = require("./StorageReader");
class StorageReaderWriter extends StorageReader_1.StorageReader {
    constructor(options) {
        super(options);
    }
    async setActive(auth, newActiveStorageIdentityKey) {
        return await this.updateUser((0, utilityHelpers_1.verifyId)(auth.userId), {
            activeStorage: newActiveStorageIdentityKey
        });
    }
    async findCertificateById(id, trx) {
        return (0, utilityHelpers_1.verifyOneOrNone)(await this.findCertificates({ partial: { certificateId: id }, trx }));
    }
    async findCommissionById(id, trx) {
        return (0, utilityHelpers_1.verifyOneOrNone)(await this.findCommissions({ partial: { commissionId: id }, trx }));
    }
    async findOutputById(id, trx, noScript) {
        return (0, utilityHelpers_1.verifyOneOrNone)(await this.findOutputs({ partial: { outputId: id }, noScript, trx }));
    }
    async findOutputBasketById(id, trx) {
        return (0, utilityHelpers_1.verifyOneOrNone)(await this.findOutputBaskets({ partial: { basketId: id }, trx }));
    }
    async findProvenTxById(id, trx) {
        return (0, utilityHelpers_1.verifyOneOrNone)(await this.findProvenTxs({ partial: { provenTxId: id }, trx }));
    }
    async findProvenTxReqById(id, trx) {
        return (0, utilityHelpers_1.verifyOneOrNone)(await this.findProvenTxReqs({ partial: { provenTxReqId: id }, trx }));
    }
    async findSyncStateById(id, trx) {
        return (0, utilityHelpers_1.verifyOneOrNone)(await this.findSyncStates({ partial: { syncStateId: id }, trx }));
    }
    async findTransactionById(id, trx, noRawTx) {
        return (0, utilityHelpers_1.verifyOneOrNone)(await this.findTransactions({
            partial: { transactionId: id },
            noRawTx,
            trx
        }));
    }
    async findTxLabelById(id, trx) {
        return (0, utilityHelpers_1.verifyOneOrNone)(await this.findTxLabels({ partial: { txLabelId: id }, trx }));
    }
    async findOutputTagById(id, trx) {
        return (0, utilityHelpers_1.verifyOneOrNone)(await this.findOutputTags({ partial: { outputTagId: id }, trx }));
    }
    async findUserById(id, trx) {
        return (0, utilityHelpers_1.verifyOneOrNone)(await this.findUsers({ partial: { userId: id }, trx }));
    }
    async findOrInsertUser(identityKey, trx) {
        let user;
        let isNew = false;
        for (let retry = 0;; retry++) {
            try {
                user = (0, utilityHelpers_1.verifyOneOrNone)(await this.findUsers({ partial: { identityKey }, trx }));
                //console.log(`findOrInsertUser oneOrNone: ${JSON.stringify(user || 'none').slice(0,512)}`)
                if (user)
                    break;
                const now = new Date();
                user = {
                    created_at: now,
                    updated_at: new Date('1971-01-01'), // Default constructed user, sync will override with any updated user.
                    userId: 0,
                    identityKey,
                    activeStorage: this.getSettings().storageIdentityKey
                };
                user.userId = await this.insertUser(user, trx);
                isNew = true;
                // Add default change basket for new user.
                await this.insertOutputBasket({
                    created_at: now,
                    updated_at: new Date('1971-01-01'), // Default constructed basket, sync will override with any updated basket.
                    basketId: 0,
                    userId: user.userId,
                    name: 'default',
                    numberOfDesiredUTXOs: 144,
                    minimumDesiredUTXOValue: 32,
                    isDeleted: false
                });
                break;
            }
            catch (eu) {
                console.log(`findOrInsertUser catch: ${JSON.stringify(eu).slice(0, 512)}`);
                if (retry > 0)
                    throw eu;
            }
        }
        return { user, isNew };
    }
    async findOrInsertTransaction(newTx, trx) {
        let tx;
        let isNew = false;
        for (let retry = 0;; retry++) {
            try {
                tx = (0, utilityHelpers_1.verifyOneOrNone)(await this.findTransactions({
                    partial: { userId: newTx.userId, txid: newTx.txid },
                    trx
                }));
                if (tx)
                    break;
                newTx.transactionId = await this.insertTransaction(newTx, trx);
                isNew = true;
                tx = newTx;
                break;
            }
            catch (eu) {
                if (retry > 0)
                    throw eu;
            }
        }
        return { tx, isNew };
    }
    async findOrInsertOutputBasket(userId, name, trx) {
        const partial = { name, userId };
        for (let retry = 0;; retry++) {
            try {
                const now = new Date();
                let basket = (0, utilityHelpers_1.verifyOneOrNone)(await this.findOutputBaskets({ partial, trx }));
                if (!basket) {
                    basket = {
                        ...partial,
                        minimumDesiredUTXOValue: 0,
                        numberOfDesiredUTXOs: 0,
                        basketId: 0,
                        created_at: now,
                        updated_at: now,
                        isDeleted: false
                    };
                    basket.basketId = await this.insertOutputBasket(basket, trx);
                }
                if (basket.isDeleted) {
                    await this.updateOutputBasket((0, utilityHelpers_1.verifyId)(basket.basketId), {
                        isDeleted: false
                    });
                }
                return basket;
            }
            catch (eu) {
                if (retry > 0)
                    throw eu;
            }
        }
    }
    async findOrInsertTxLabel(userId, label, trx) {
        const partial = { label, userId };
        for (let retry = 0;; retry++) {
            try {
                const now = new Date();
                let txLabel = (0, utilityHelpers_1.verifyOneOrNone)(await this.findTxLabels({ partial, trx }));
                if (!txLabel) {
                    txLabel = {
                        ...partial,
                        txLabelId: 0,
                        created_at: now,
                        updated_at: now,
                        isDeleted: false
                    };
                    txLabel.txLabelId = await this.insertTxLabel(txLabel, trx);
                }
                if (txLabel.isDeleted) {
                    await this.updateTxLabel((0, utilityHelpers_1.verifyId)(txLabel.txLabelId), {
                        isDeleted: false
                    });
                }
                return txLabel;
            }
            catch (eu) {
                if (retry > 0)
                    throw eu;
            }
        }
    }
    async findOrInsertTxLabelMap(transactionId, txLabelId, trx) {
        const partial = { transactionId, txLabelId };
        for (let retry = 0;; retry++) {
            try {
                const now = new Date();
                let txLabelMap = (0, utilityHelpers_1.verifyOneOrNone)(await this.findTxLabelMaps({ partial, trx }));
                if (!txLabelMap) {
                    txLabelMap = {
                        ...partial,
                        created_at: now,
                        updated_at: now,
                        isDeleted: false
                    };
                    await this.insertTxLabelMap(txLabelMap, trx);
                }
                if (txLabelMap.isDeleted) {
                    await this.updateTxLabelMap(transactionId, txLabelId, {
                        isDeleted: false
                    });
                }
                return txLabelMap;
            }
            catch (eu) {
                if (retry > 0)
                    throw eu;
            }
        }
    }
    async findOrInsertOutputTag(userId, tag, trx) {
        const partial = { tag, userId };
        for (let retry = 0;; retry++) {
            try {
                const now = new Date();
                let outputTag = (0, utilityHelpers_1.verifyOneOrNone)(await this.findOutputTags({ partial, trx }));
                if (!outputTag) {
                    outputTag = {
                        ...partial,
                        outputTagId: 0,
                        created_at: now,
                        updated_at: now,
                        isDeleted: false
                    };
                    outputTag.outputTagId = await this.insertOutputTag(outputTag, trx);
                }
                if (outputTag.isDeleted) {
                    await this.updateOutputTag((0, utilityHelpers_1.verifyId)(outputTag.outputTagId), {
                        isDeleted: false
                    });
                }
                return outputTag;
            }
            catch (eu) {
                if (retry > 0)
                    throw eu;
            }
        }
    }
    async findOrInsertOutputTagMap(outputId, outputTagId, trx) {
        const partial = { outputId, outputTagId };
        for (let retry = 0;; retry++) {
            try {
                const now = new Date();
                let outputTagMap = (0, utilityHelpers_1.verifyOneOrNone)(await this.findOutputTagMaps({ partial, trx }));
                if (!outputTagMap) {
                    outputTagMap = {
                        ...partial,
                        created_at: now,
                        updated_at: now,
                        isDeleted: false
                    };
                    await this.insertOutputTagMap(outputTagMap, trx);
                }
                if (outputTagMap.isDeleted) {
                    await this.updateOutputTagMap(outputId, outputTagId, {
                        isDeleted: false
                    });
                }
                return outputTagMap;
            }
            catch (eu) {
                if (retry > 0)
                    throw eu;
            }
        }
    }
    async findOrInsertSyncStateAuth(auth, storageIdentityKey, storageName) {
        const partial = { userId: auth.userId, storageIdentityKey, storageName };
        for (let retry = 0;; retry++) {
            try {
                const now = new Date();
                let syncState = (0, utilityHelpers_1.verifyOneOrNone)(await this.findSyncStates({ partial }));
                if (!syncState) {
                    syncState = {
                        ...partial,
                        created_at: now,
                        updated_at: now,
                        syncStateId: 0,
                        status: 'unknown',
                        init: false,
                        refNum: (0, utilityHelpers_1.randomBytesBase64)(12),
                        syncMap: JSON.stringify((0, entities_1.createSyncMap)())
                    };
                    await this.insertSyncState(syncState);
                    return { syncState, isNew: true };
                }
                return { syncState, isNew: false };
            }
            catch (eu) {
                if (retry > 0)
                    throw eu;
            }
        }
    }
    async findOrInsertProvenTxReq(newReq, trx) {
        let req;
        let isNew = false;
        for (let retry = 0;; retry++) {
            try {
                req = (0, utilityHelpers_1.verifyOneOrNone)(await this.findProvenTxReqs({ partial: { txid: newReq.txid }, trx }));
                if (req)
                    break;
                newReq.provenTxReqId = await this.insertProvenTxReq(newReq, trx);
                isNew = true;
                req = newReq;
                break;
            }
            catch (eu) {
                if (retry > 0)
                    throw eu;
            }
        }
        return { req, isNew };
    }
    async findOrInsertProvenTx(newProven, trx) {
        let proven;
        let isNew = false;
        for (let retry = 0;; retry++) {
            try {
                proven = (0, utilityHelpers_1.verifyOneOrNone)(await this.findProvenTxs({ partial: { txid: newProven.txid }, trx }));
                if (proven)
                    break;
                newProven.provenTxId = await this.insertProvenTx(newProven, trx);
                isNew = true;
                proven = newProven;
                break;
            }
            catch (eu) {
                if (retry > 0)
                    throw eu;
            }
        }
        return { proven, isNew };
    }
    async tagOutput(partial, tag, trx) {
        await this.transaction(async (trx) => {
            const o = (0, utilityHelpers_1.verifyOne)(await this.findOutputs({ partial, noScript: true, trx }));
            const outputTag = await this.findOrInsertOutputTag(o.userId, tag, trx);
            await this.findOrInsertOutputTagMap((0, utilityHelpers_1.verifyId)(o.outputId), (0, utilityHelpers_1.verifyId)(outputTag.outputTagId), trx);
        }, trx);
    }
}
exports.StorageReaderWriter = StorageReaderWriter;
//# sourceMappingURL=StorageReaderWriter.js.map