import { sdk, StorageProvider, TableProvenTxReq, WalletStorageManager } from '../../../index.client';
import { EntityBase, EntityStorage, SyncMap } from '.';
export declare class EntityProvenTxReq extends EntityBase<TableProvenTxReq> {
    static fromStorageTxid(storage: EntityStorage, txid: string, trx?: sdk.TrxToken): Promise<EntityProvenTxReq | undefined>;
    static fromStorageId(storage: EntityStorage, id: number, trx?: sdk.TrxToken): Promise<EntityProvenTxReq>;
    static fromTxid(txid: string, rawTx: number[], inputBEEF?: number[]): EntityProvenTxReq;
    history: ProvenTxReqHistory;
    notify: ProvenTxReqNotify;
    packApiHistory(): void;
    packApiNotify(): void;
    unpackApiHistory(): void;
    unpackApiNotify(): void;
    get apiHistory(): string;
    get apiNotify(): string;
    set apiHistory(v: string);
    set apiNotify(v: string);
    updateApi(): void;
    unpackApi(): void;
    refreshFromStorage(storage: EntityStorage | WalletStorageManager, trx?: sdk.TrxToken): Promise<void>;
    constructor(api?: TableProvenTxReq);
    /**
     * Returns history to only what followed since date.
     */
    historySince(since: Date): ProvenTxReqHistory;
    historyPretty(since?: Date, indent?: number): string;
    prettyNote(note: sdk.ReqHistoryNote): string;
    getHistorySummary(): ProvenTxReqHistorySummaryApi;
    parseHistoryNote(note: sdk.ReqHistoryNote, summary?: ProvenTxReqHistorySummaryApi): string;
    addNotifyTransactionId(id: number): void;
    /**
     * Adds a note to history.
     * Notes with identical property values to an existing note are ignored.
     * @param note Note to add
     * @param noDupes if true, only newest note with same `what` value is retained.
     */
    addHistoryNote(note: sdk.ReqHistoryNote, noDupes?: boolean): void;
    /**
       * Updates database record with current state of this EntityUser
  
       * @param storage
       * @param trx
       */
    updateStorage(storage: EntityStorage, trx?: sdk.TrxToken): Promise<void>;
    /**
     * Update storage with changes to non-static properties:
     *   updated_at
     *   provenTxId
     *   status
     *   history
     *   notify
     *   notified
     *   attempts
     *   batch
     *
     * @param storage
     * @param trx
     */
    updateStorageDynamicProperties(storage: WalletStorageManager | StorageProvider, trx?: sdk.TrxToken): Promise<void>;
    insertOrMerge(storage: EntityStorage, trx?: sdk.TrxToken): Promise<EntityProvenTxReq>;
    /**
     * See `ProvenTxReqStatusApi`
     */
    get status(): sdk.ProvenTxReqStatus;
    set status(v: sdk.ProvenTxReqStatus);
    get provenTxReqId(): number;
    set provenTxReqId(v: number);
    get created_at(): Date;
    set created_at(v: Date);
    get updated_at(): Date;
    set updated_at(v: Date);
    get txid(): string;
    set txid(v: string);
    get inputBEEF(): number[] | undefined;
    set inputBEEF(v: number[] | undefined);
    get rawTx(): number[];
    set rawTx(v: number[]);
    get attempts(): number;
    set attempts(v: number);
    get provenTxId(): number | undefined;
    set provenTxId(v: number | undefined);
    get notified(): boolean;
    set notified(v: boolean);
    get batch(): string | undefined;
    set batch(v: string | undefined);
    get id(): number;
    set id(v: number);
    get entityName(): string;
    get entityTable(): string;
    /**
     * 'convergent' equality must satisfy (A sync B) equals (B sync A)
     */
    equals(ei: TableProvenTxReq, syncMap?: SyncMap | undefined): boolean;
    static mergeFind(storage: EntityStorage, userId: number, ei: TableProvenTxReq, syncMap: SyncMap, trx?: sdk.TrxToken): Promise<{
        found: boolean;
        eo: EntityProvenTxReq;
        eiId: number;
    }>;
    mapNotifyTransactionIds(syncMap: SyncMap): void;
    mergeNotifyTransactionIds(ei: TableProvenTxReq, syncMap?: SyncMap): void;
    mergeHistory(ei: TableProvenTxReq, syncMap?: SyncMap, noDupes?: boolean): void;
    static isTerminalStatus(status: sdk.ProvenTxReqStatus): boolean;
    mergeNew(storage: EntityStorage, userId: number, syncMap: SyncMap, trx?: sdk.TrxToken): Promise<void>;
    /**
     * When merging `ProvenTxReq`, care is taken to avoid short-cirtuiting notification: `status` must not transition to `completed` without
     * passing through `notifying`. Thus a full convergent merge passes through these sequence steps:
     * 1. Remote storage completes before local storage.
     * 2. The remotely completed req and ProvenTx sync to local storage.
     * 3. The local storage transitions to `notifying`, after merging the remote attempts and history.
     * 4. The local storage notifies, transitioning to `completed`.
     * 5. Having been updated, the local req, but not ProvenTx sync to remote storage, but do not merge because the earlier `completed` wins.
     * 6. Convergent equality is achieved (completing work - history and attempts are equal)
     *
     * On terminal failure: `doubleSpend` trumps `invalid` as it contains more data.
     */
    mergeExisting(storage: EntityStorage, since: Date | undefined, ei: TableProvenTxReq, syncMap: SyncMap, trx?: sdk.TrxToken): Promise<boolean>;
}
export interface ProvenTxReqHistorySummaryApi {
    setToCompleted: boolean;
    setToCallback: boolean;
    setToUnmined: boolean;
    setToDoubleSpend: boolean;
    setToSending: boolean;
    setToUnconfirmed: boolean;
}
export interface ProvenTxReqHistory {
    /**
     * Keys are Date().toISOString()
     * Values are a description of what happened.
     */
    notes?: sdk.ReqHistoryNote[];
}
export interface ProvenTxReqNotify {
    transactionIds?: number[];
}
//# sourceMappingURL=EntityProvenTxReq.d.ts.map