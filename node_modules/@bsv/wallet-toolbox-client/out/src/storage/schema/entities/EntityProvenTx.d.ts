import { MerklePath } from '@bsv/sdk';
import { sdk, TableProvenTx } from '../../../index.client';
import { EntityBase, EntityProvenTxReq, EntityStorage, SyncMap } from '.';
export declare class EntityProvenTx extends EntityBase<TableProvenTx> {
    /**
     * Given a txid and optionally its rawTx, create a new ProvenTx object.
     *
     * rawTx is fetched if not provided.
     *
     * Only succeeds (proven is not undefined) if a proof is confirmed for rawTx,
     * and hash of rawTx is confirmed to match txid
     *
     * The returned ProvenTx and ProvenTxReq objects have not been added to the storage database,
     * this is optional and can be done by the caller if appropriate.
     *
     * @param txid
     * @param services
     * @param rawTx
     * @returns
     */
    static fromTxid(txid: string, services: sdk.WalletServices, rawTx?: number[]): Promise<ProvenTxFromTxidResult>;
    constructor(api?: TableProvenTx);
    updateApi(): void;
    /**
     * @returns desirialized `MerklePath` object, value is cached.
     */
    getMerklePath(): MerklePath;
    _mp?: MerklePath;
    get provenTxId(): number;
    set provenTxId(v: number);
    get created_at(): Date;
    set created_at(v: Date);
    get updated_at(): Date;
    set updated_at(v: Date);
    get txid(): string;
    set txid(v: string);
    get height(): number;
    set height(v: number);
    get index(): number;
    set index(v: number);
    get merklePath(): number[];
    set merklePath(v: number[]);
    get rawTx(): number[];
    set rawTx(v: number[]);
    get blockHash(): string;
    set blockHash(v: string);
    get merkleRoot(): string;
    set merkleRoot(v: string);
    get id(): number;
    set id(v: number);
    get entityName(): string;
    get entityTable(): string;
    equals(ei: TableProvenTx, syncMap?: SyncMap | undefined): boolean;
    static mergeFind(storage: EntityStorage, userId: number, ei: TableProvenTx, syncMap: SyncMap, trx?: sdk.TrxToken): Promise<{
        found: boolean;
        eo: EntityProvenTx;
        eiId: number;
    }>;
    mergeNew(storage: EntityStorage, userId: number, syncMap: SyncMap, trx?: sdk.TrxToken): Promise<void>;
    mergeExisting(storage: EntityStorage, since: Date | undefined, ei: TableProvenTx, syncMap: SyncMap, trx?: sdk.TrxToken): Promise<boolean>;
    /**
     * How high attempts can go before status is forced to invalid
     */
    static getProofAttemptsLimit: number;
    /**
     * How many hours we have to try for a poof
     */
    static getProofMinutes: number;
    /**
     * Try to create a new ProvenTx from a ProvenTxReq and GetMerkleProofResultApi
     *
     * Otherwise it returns undefined and updates req.status to either 'unknown', 'invalid', or 'unconfirmed'
     *
     * @param req
     * @param gmpResult
     * @returns
     */
    static fromReq(req: EntityProvenTxReq, gmpResult: sdk.GetMerklePathResult, countsAsAttempt: boolean): Promise<EntityProvenTx | undefined>;
}
export interface ProvenTxFromTxidResult {
    proven?: EntityProvenTx;
    rawTx?: number[];
}
//# sourceMappingURL=EntityProvenTx.d.ts.map