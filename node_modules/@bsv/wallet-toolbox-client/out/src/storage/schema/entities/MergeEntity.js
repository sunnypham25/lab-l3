"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MergeEntity = void 0;
const index_client_1 = require("../../../index.client");
/**
 * @param API one of the storage table interfaces.
 * @param DE the corresponding entity class
 */
class MergeEntity {
    constructor(stateArray, find, 
    /** id map for primary id of API and DE object. */
    esm) {
        this.stateArray = stateArray;
        this.find = find;
        this.esm = esm;
        this.idMap = esm.idMap;
    }
    updateSyncMap(map, inId, outId) {
        const i = (0, index_client_1.verifyId)(inId);
        const o = (0, index_client_1.verifyId)(outId);
        if (map[i] === undefined) {
            map[i] = o;
        }
        else if (map[i] !== o)
            throw new index_client_1.sdk.WERR_INTERNAL(`updateSyncMap map[${inId}] can't override ${map[i]} with ${o}`);
    }
    /**
     * @param since date of current sync chunk
     */
    async merge(since, storage, userId, syncMap, trx) {
        let inserts = 0, updates = 0;
        if (!this.stateArray)
            return { inserts, updates };
        for (const ei of this.stateArray) {
            this.esm.maxUpdated_at = (0, index_client_1.maxDate)(this.esm.maxUpdated_at, ei.updated_at);
            /**
             * TODO:
             * Switch to using syncMap. If the ei id is in the map its an existing merge, else its a new merge.
             */
            try {
                const { found, eo, eiId } = await this.find(storage, userId, ei, syncMap, trx);
                if (found) {
                    if (await eo.mergeExisting(storage, since, ei, syncMap, trx)) {
                        updates++;
                    }
                }
                else {
                    await eo.mergeNew(storage, userId, syncMap, trx);
                    inserts++;
                }
                if (eiId > -1)
                    this.updateSyncMap(this.idMap, eiId, eo.id);
            }
            catch (eu) {
                throw eu;
            }
        }
        return { inserts, updates };
    }
}
exports.MergeEntity = MergeEntity;
//# sourceMappingURL=MergeEntity.js.map