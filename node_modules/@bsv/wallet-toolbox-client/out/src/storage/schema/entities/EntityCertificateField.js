"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EntityCertificateField = void 0;
const index_client_1 = require("../../../index.client");
const _1 = require(".");
class EntityCertificateField extends _1.EntityBase {
    constructor(api) {
        const now = new Date();
        super(api || {
            created_at: now,
            updated_at: now,
            userId: 0,
            certificateId: 0,
            fieldName: '',
            fieldValue: '',
            masterKey: ''
        });
    }
    updateApi() {
        /* nothing needed yet... */
    }
    get userId() {
        return this.api.userId;
    }
    set userId(v) {
        this.api.userId = v;
    }
    get certificateId() {
        return this.api.certificateId;
    }
    set certificateId(v) {
        this.api.certificateId = v;
    }
    get created_at() {
        return this.api.created_at;
    }
    set created_at(v) {
        this.api.created_at = v;
    }
    get updated_at() {
        return this.api.updated_at;
    }
    set updated_at(v) {
        this.api.updated_at = v;
    }
    get fieldName() {
        return this.api.fieldName;
    }
    set fieldName(v) {
        this.api.fieldName = v;
    }
    get fieldValue() {
        return this.api.fieldValue;
    }
    set fieldValue(v) {
        this.api.fieldValue = v;
    }
    get masterKey() {
        return this.api.masterKey;
    }
    set masterKey(v) {
        this.api.masterKey = v;
    }
    get id() {
        throw new index_client_1.sdk.WERR_INVALID_OPERATION('entity has no "id" value');
    }
    get entityName() {
        return 'certificateField';
    }
    get entityTable() {
        return 'certificate_fields';
    }
    equals(ei, syncMap) {
        if (this.certificateId !== (syncMap ? syncMap.certificate.idMap[ei.certificateId] : ei.certificateId) ||
            this.fieldName !== ei.fieldName ||
            this.fieldValue !== ei.fieldValue ||
            this.masterKey !== ei.masterKey)
            return false;
        return true;
    }
    static async mergeFind(storage, userId, ei, syncMap, trx) {
        const certificateId = syncMap.certificate.idMap[ei.certificateId];
        const ef = (0, index_client_1.verifyOneOrNone)(await storage.findCertificateFields({
            partial: { certificateId, userId, fieldName: ei.fieldName },
            trx
        }));
        return {
            found: !!ef,
            eo: new EntityCertificateField(ef || { ...ei }),
            eiId: -1
        };
    }
    async mergeNew(storage, userId, syncMap, trx) {
        this.certificateId = syncMap.certificate.idMap[this.certificateId];
        this.userId = userId;
        await storage.insertCertificateField(this.toApi(), trx);
    }
    async mergeExisting(storage, since, ei, syncMap, trx) {
        let wasMerged = false;
        if (ei.updated_at > this.updated_at) {
            this.fieldValue = ei.fieldValue;
            this.masterKey = ei.masterKey;
            this.updated_at = new Date(Math.max(ei.updated_at.getTime(), this.updated_at.getTime()));
            await storage.updateCertificateField(this.certificateId, this.fieldName, this.toApi(), trx);
            wasMerged = true;
        }
        return wasMerged;
    }
}
exports.EntityCertificateField = EntityCertificateField;
//# sourceMappingURL=EntityCertificateField.js.map