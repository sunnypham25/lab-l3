"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EntityUser = void 0;
const index_client_1 = require("../../../index.client");
const _1 = require(".");
class EntityUser extends _1.EntityBase {
    constructor(api) {
        const now = new Date();
        super(api || {
            userId: 0,
            created_at: now,
            updated_at: now,
            identityKey: '',
            activeStorage: ''
        });
    }
    updateApi() {
        /* nothing needed yet... */
    }
    get userId() {
        return this.api.userId;
    }
    set userId(v) {
        this.api.userId = v;
    }
    get created_at() {
        return this.api.created_at;
    }
    set created_at(v) {
        this.api.created_at = v;
    }
    get updated_at() {
        return this.api.updated_at;
    }
    set updated_at(v) {
        this.api.updated_at = v;
    }
    get identityKey() {
        return this.api.identityKey;
    }
    set identityKey(v) {
        this.api.identityKey = v;
    }
    get activeStorage() {
        return this.api.activeStorage;
    }
    set activeStorage(v) {
        this.api.activeStorage = v;
    }
    get id() {
        return this.api.userId;
    }
    set id(v) {
        this.api.userId = v;
    }
    get entityName() {
        return 'user';
    }
    get entityTable() {
        return 'users';
    }
    equals(ei, syncMap) {
        const eo = this.toApi();
        if (eo.identityKey != ei.identityKey || eo.activeStorage != ei.activeStorage)
            return false;
        if (!syncMap) {
            /** */
        }
        return true;
    }
    static async mergeFind(storage, userId, ei, trx) {
        const ef = (0, index_client_1.verifyOneOrNone)(await storage.findUsers({ partial: { identityKey: ei.identityKey }, trx }));
        if (ef && ef.userId != userId)
            throw new index_client_1.sdk.WERR_INTERNAL('logic error, userIds don not match.');
        return {
            found: !!ef,
            eo: new EntityUser(ef || { ...ei }),
            eiId: (0, index_client_1.verifyId)(ei.userId)
        };
    }
    async mergeNew(storage, userId, syncMap, trx) {
        throw new index_client_1.sdk.WERR_INTERNAL('a sync chunk merge must never create a new user');
    }
    async mergeExisting(storage, since, ei, syncMap, trx) {
        let wasMerged = false;
        // The condition on activeStorage here is critical as a new user record may have just been created
        // in a backup store to which a backup is being pushed.
        if (ei.updated_at > this.updated_at || (this.activeStorage === undefined && ei.activeStorage !== undefined)) {
            this.activeStorage = ei.activeStorage;
            this.updated_at = new Date(Math.max(ei.updated_at.getTime(), this.updated_at.getTime()));
            await storage.updateUser(this.id, this.toApi(), trx);
            wasMerged = true;
        }
        return wasMerged;
    }
}
exports.EntityUser = EntityUser;
//# sourceMappingURL=EntityUser.js.map