"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EntityTransaction = void 0;
/* eslint-disable @typescript-eslint/no-unused-vars */
const sdk_1 = require("@bsv/sdk");
const index_client_1 = require("../../../index.client");
const _1 = require(".");
class EntityTransaction extends _1.EntityBase {
    /**
     * @returns @bsv/sdk Transaction object from parsed rawTx.
     * If rawTx is undefined, returns undefined.
     */
    getBsvTx() {
        if (!this.rawTx)
            return undefined;
        return sdk_1.Transaction.fromBinary(this.rawTx);
    }
    /**
     * @returns array of @bsv/sdk TransactionInput objects from parsed rawTx.
     * If rawTx is undefined, an empty array is returned.
     */
    getBsvTxIns() {
        const tx = this.getBsvTx();
        if (!tx)
            return [];
        return tx.inputs;
    }
    /**
     * Returns an array of "known" inputs to this transaction which belong to the same userId.
     * Uses both spentBy and rawTx inputs (if available) to locate inputs from among user's outputs.
     * Not all transaction inputs correspond to prior storage outputs.
     */
    async getInputs(storage, trx) {
        const inputs = await storage.findOutputs({
            partial: { userId: this.userId, spentBy: this.id },
            trx
        });
        // Merge "inputs" by spentBy and userId
        for (const input of this.getBsvTxIns()) {
            //console.log(`getInputs of ${this.id}: ${input.txid()} ${input.txOutNum}`)
            const pso = (0, index_client_1.verifyOneOrNone)(await storage.findOutputs({
                partial: {
                    userId: this.userId,
                    txid: input.sourceTXID,
                    vout: input.sourceOutputIndex
                },
                trx
            }));
            if (pso && !inputs.some(i => i.outputId === pso.outputId))
                inputs.push(pso);
        }
        return inputs;
    }
    constructor(api) {
        const now = new Date();
        super(api || {
            transactionId: 0,
            created_at: now,
            updated_at: now,
            userId: 0,
            txid: '',
            status: 'unprocessed',
            reference: '',
            satoshis: 0,
            description: '',
            isOutgoing: false,
            rawTx: undefined,
            inputBEEF: undefined
        });
    }
    updateApi() {
        /* nothing needed yet... */
    }
    get transactionId() {
        return this.api.transactionId;
    }
    set transactionId(v) {
        this.api.transactionId = v;
    }
    get created_at() {
        return this.api.created_at;
    }
    set created_at(v) {
        this.api.created_at = v;
    }
    get updated_at() {
        return this.api.updated_at;
    }
    set updated_at(v) {
        this.api.updated_at = v;
    }
    get version() {
        return this.api.version;
    }
    set version(v) {
        this.api.version = v;
    }
    get lockTime() {
        return this.api.lockTime;
    }
    set lockTime(v) {
        this.api.lockTime = v;
    }
    get isOutgoing() {
        return this.api.isOutgoing;
    }
    set isOutgoing(v) {
        this.api.isOutgoing = v;
    }
    get status() {
        return this.api.status;
    }
    set status(v) {
        this.api.status = v;
    }
    get userId() {
        return this.api.userId;
    }
    set userId(v) {
        this.api.userId = v;
    }
    get provenTxId() {
        return this.api.provenTxId;
    }
    set provenTxId(v) {
        this.api.provenTxId = v;
    }
    get satoshis() {
        return this.api.satoshis;
    }
    set satoshis(v) {
        this.api.satoshis = v;
    }
    get txid() {
        return this.api.txid;
    }
    set txid(v) {
        this.api.txid = v;
    }
    get reference() {
        return this.api.reference;
    }
    set reference(v) {
        this.api.reference = v;
    }
    get inputBEEF() {
        return this.api.inputBEEF;
    }
    set inputBEEF(v) {
        this.api.inputBEEF = v;
    }
    get description() {
        return this.api.description;
    }
    set description(v) {
        this.api.description = v;
    }
    get rawTx() {
        return this.api.rawTx;
    }
    set rawTx(v) {
        this.api.rawTx = v;
    }
    // Extended (computed / dependent entity) Properties
    //get labels() { return this.api.labels }
    //set labels(v: string[] | undefined) { this.api.labels = v }
    get id() {
        return this.api.transactionId;
    }
    set id(v) {
        this.api.transactionId = v;
    }
    get entityName() {
        return 'transaction';
    }
    get entityTable() {
        return 'transactions';
    }
    equals(ei, syncMap) {
        const eo = this.toApi();
        // Properties that are never updated
        if (eo.transactionId !== (syncMap ? syncMap.transaction.idMap[(0, index_client_1.verifyId)(ei.transactionId)] : ei.transactionId) ||
            eo.reference !== ei.reference)
            return false;
        if (eo.version !== ei.version ||
            eo.lockTime !== ei.lockTime ||
            eo.isOutgoing !== ei.isOutgoing ||
            eo.status !== ei.status ||
            eo.satoshis !== ei.satoshis ||
            eo.txid !== ei.txid ||
            eo.description !== ei.description ||
            !(0, index_client_1.optionalArraysEqual)(eo.rawTx, ei.rawTx) ||
            !(0, index_client_1.optionalArraysEqual)(eo.inputBEEF, ei.inputBEEF))
            return false;
        if (!eo.provenTxId !== !ei.provenTxId ||
            (ei.provenTxId && eo.provenTxId !== (syncMap ? syncMap.provenTx.idMap[(0, index_client_1.verifyId)(ei.provenTxId)] : ei.provenTxId)))
            return false;
        return true;
    }
    static async mergeFind(storage, userId, ei, syncMap, trx) {
        const ef = (0, index_client_1.verifyOneOrNone)(await storage.findTransactions({
            partial: { reference: ei.reference, userId },
            trx
        }));
        return {
            found: !!ef,
            eo: new EntityTransaction(ef || { ...ei }),
            eiId: (0, index_client_1.verifyId)(ei.transactionId)
        };
    }
    async mergeNew(storage, userId, syncMap, trx) {
        if (this.provenTxId)
            this.provenTxId = syncMap.provenTx.idMap[this.provenTxId];
        this.userId = userId;
        this.transactionId = 0;
        this.transactionId = await storage.insertTransaction(this.toApi(), trx);
    }
    async mergeExisting(storage, since, ei, syncMap, trx) {
        let wasMerged = false;
        if (ei.updated_at > this.updated_at) {
            // Properties that are never updated:
            // transactionId
            // userId
            // reference
            // Merged properties
            this.version = ei.version;
            this.lockTime = ei.lockTime;
            this.isOutgoing = ei.isOutgoing;
            this.status = ei.status;
            this.provenTxId = ei.provenTxId ? syncMap.provenTx.idMap[ei.provenTxId] : undefined;
            this.satoshis = ei.satoshis;
            this.txid = ei.txid;
            this.description = ei.description;
            this.rawTx = ei.rawTx;
            this.inputBEEF = ei.inputBEEF;
            this.updated_at = new Date(Math.max(ei.updated_at.getTime(), this.updated_at.getTime()));
            await storage.updateTransaction(this.id, this.toApi(), trx);
            wasMerged = true;
        }
        return wasMerged;
    }
    async getProvenTx(storage, trx) {
        if (!this.provenTxId)
            return undefined;
        const p = (0, index_client_1.verifyOneOrNone)(await storage.findProvenTxs({
            partial: { provenTxId: this.provenTxId },
            trx
        }));
        if (!p)
            return undefined;
        return new _1.EntityProvenTx(p);
    }
}
exports.EntityTransaction = EntityTransaction;
//# sourceMappingURL=EntityTransaction.js.map