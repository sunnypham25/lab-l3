"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EntityCommission = void 0;
const index_client_1 = require("../../../index.client");
const _1 = require(".");
class EntityCommission extends _1.EntityBase {
    constructor(api) {
        const now = new Date();
        super(api || {
            commissionId: 0,
            created_at: now,
            updated_at: now,
            transactionId: 0,
            userId: 0,
            isRedeemed: false,
            keyOffset: '',
            lockingScript: [],
            satoshis: 0
        });
    }
    updateApi() {
        /* nothing needed yet... */
    }
    get commissionId() {
        return this.api.commissionId;
    }
    set commissionId(v) {
        this.api.commissionId = v;
    }
    get created_at() {
        return this.api.created_at;
    }
    set created_at(v) {
        this.api.created_at = v;
    }
    get updated_at() {
        return this.api.updated_at;
    }
    set updated_at(v) {
        this.api.updated_at = v;
    }
    get transactionId() {
        return this.api.transactionId;
    }
    set transactionId(v) {
        this.api.transactionId = v;
    }
    get userId() {
        return this.api.userId;
    }
    set userId(v) {
        this.api.userId = v;
    }
    get isRedeemed() {
        return this.api.isRedeemed;
    }
    set isRedeemed(v) {
        this.api.isRedeemed = v;
    }
    get keyOffset() {
        return this.api.keyOffset;
    }
    set keyOffset(v) {
        this.api.keyOffset = v;
    }
    get lockingScript() {
        return this.api.lockingScript;
    }
    set lockingScript(v) {
        this.api.lockingScript = v;
    }
    get satoshis() {
        return this.api.satoshis;
    }
    set satoshis(v) {
        this.api.satoshis = v;
    }
    get id() {
        return this.api.commissionId;
    }
    set id(v) {
        this.api.commissionId = v;
    }
    get entityName() {
        return 'commission';
    }
    get entityTable() {
        return 'commissions';
    }
    equals(ei, syncMap) {
        if (this.isRedeemed !== ei.isRedeemed ||
            this.transactionId !== (syncMap ? syncMap.transaction.idMap[ei.transactionId] : ei.transactionId) ||
            this.keyOffset !== ei.keyOffset ||
            !(0, index_client_1.arraysEqual)(this.lockingScript, ei.lockingScript) ||
            this.satoshis !== ei.satoshis)
            return false;
        return true;
    }
    static async mergeFind(storage, userId, ei, syncMap, trx) {
        const transactionId = syncMap.transaction.idMap[ei.transactionId];
        const ef = (0, index_client_1.verifyOneOrNone)(await storage.findCommissions({ partial: { transactionId, userId }, trx }));
        return {
            found: !!ef,
            eo: new EntityCommission(ef || { ...ei }),
            eiId: (0, index_client_1.verifyId)(ei.commissionId)
        };
    }
    async mergeNew(storage, userId, syncMap, trx) {
        if (this.transactionId)
            this.transactionId = syncMap.transaction.idMap[this.transactionId];
        this.userId = userId;
        this.commissionId = 0;
        this.commissionId = await storage.insertCommission(this.toApi(), trx);
    }
    async mergeExisting(storage, since, ei, syncMap, trx) {
        let wasMerged = false;
        if (ei.updated_at > this.updated_at) {
            this.isRedeemed = ei.isRedeemed;
            this.updated_at = new Date(Math.max(ei.updated_at.getTime(), this.updated_at.getTime()));
            await storage.updateCommission(this.id, this.toApi(), trx);
            wasMerged = true;
        }
        return wasMerged;
    }
}
exports.EntityCommission = EntityCommission;
//# sourceMappingURL=EntityCommission.js.map