"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EntityOutputBasket = void 0;
const index_client_1 = require("../../../index.client");
const _1 = require(".");
class EntityOutputBasket extends _1.EntityBase {
    constructor(api) {
        const now = new Date();
        super(api || {
            basketId: 0,
            created_at: now,
            updated_at: now,
            userId: 0,
            name: '',
            numberOfDesiredUTXOs: 0,
            minimumDesiredUTXOValue: 0,
            isDeleted: false
        });
    }
    get basketId() {
        return this.api.basketId;
    }
    set basketId(v) {
        this.api.basketId = v;
    }
    get created_at() {
        return this.api.created_at;
    }
    set created_at(v) {
        this.api.created_at = v;
    }
    get updated_at() {
        return this.api.updated_at;
    }
    set updated_at(v) {
        this.api.updated_at = v;
    }
    get userId() {
        return this.api.userId;
    }
    set userId(v) {
        this.api.userId = v;
    }
    get name() {
        return this.api.name;
    }
    set name(v) {
        this.api.name = v;
    }
    get numberOfDesiredUTXOs() {
        return this.api.numberOfDesiredUTXOs;
    }
    set numberOfDesiredUTXOs(v) {
        this.api.numberOfDesiredUTXOs = v;
    }
    get minimumDesiredUTXOValue() {
        return this.api.minimumDesiredUTXOValue;
    }
    set minimumDesiredUTXOValue(v) {
        this.api.minimumDesiredUTXOValue = v;
    }
    get isDeleted() {
        return this.api.isDeleted;
    }
    set isDeleted(v) {
        this.api.isDeleted = v;
    }
    get id() {
        return this.api.basketId;
    }
    set id(v) {
        this.api.basketId = v;
    }
    get entityName() {
        return 'outputBasket';
    }
    get entityTable() {
        return 'output_baskets';
    }
    updateApi() {
        /* nothing needed yet... */
    }
    equals(ei, syncMap) {
        const eo = this.api;
        if (eo.name != ei.name ||
            eo.numberOfDesiredUTXOs != ei.numberOfDesiredUTXOs ||
            eo.minimumDesiredUTXOValue != ei.minimumDesiredUTXOValue)
            return false;
        if (syncMap) {
            if (eo.basketId !== syncMap.outputBasket.idMap[(0, index_client_1.verifyId)(ei.basketId)])
                return false;
        }
        else {
            if (eo.basketId !== ei.basketId || eo.userId !== ei.userId)
                return false;
        }
        return true;
    }
    static async mergeFind(storage, userId, ei, syncMap, trx) {
        const ef = (0, index_client_1.verifyOneOrNone)(await storage.findOutputBaskets({
            partial: { name: ei.name, userId },
            trx
        }));
        return {
            found: !!ef,
            eo: new EntityOutputBasket(ef || { ...ei }),
            eiId: (0, index_client_1.verifyId)(ei.basketId)
        };
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async mergeNew(storage, userId, syncMap, trx) {
        this.userId = userId;
        this.name || (this.name = 'default');
        this.basketId = 0;
        this.basketId = await storage.insertOutputBasket(this.toApi(), trx);
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async mergeExisting(storage, since, ei, syncMap, trx) {
        let wasMerged = false;
        if (ei.updated_at > this.updated_at) {
            // basket name is its identity, should not change
            this.minimumDesiredUTXOValue = ei.minimumDesiredUTXOValue;
            this.numberOfDesiredUTXOs = ei.numberOfDesiredUTXOs;
            this.isDeleted = ei.isDeleted;
            this.updated_at = new Date(Math.max(ei.updated_at.getTime(), this.updated_at.getTime()));
            await storage.updateOutputBasket(this.id, this.toApi(), trx);
            wasMerged = true;
        }
        return wasMerged;
    }
}
exports.EntityOutputBasket = EntityOutputBasket;
//# sourceMappingURL=EntityOutputBasket.js.map