"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseWalletOutpoint = parseWalletOutpoint;
exports.validateSatoshis = validateSatoshis;
exports.validateOptionalInteger = validateOptionalInteger;
exports.validateInteger = validateInteger;
exports.validatePositiveIntegerOrZero = validatePositiveIntegerOrZero;
exports.validateStringLength = validateStringLength;
exports.isHexString = isHexString;
exports.validateCreateActionInput = validateCreateActionInput;
exports.validateCreateActionOutput = validateCreateActionOutput;
exports.validateCreateActionOptions = validateCreateActionOptions;
exports.validateCreateActionArgs = validateCreateActionArgs;
exports.validateSignActionOptions = validateSignActionOptions;
exports.validateSignActionArgs = validateSignActionArgs;
exports.validateAbortActionArgs = validateAbortActionArgs;
exports.validateWalletPayment = validateWalletPayment;
exports.validateBasketInsertion = validateBasketInsertion;
exports.validateInternalizeOutput = validateInternalizeOutput;
exports.validateOriginator = validateOriginator;
exports.validateInternalizeActionArgs = validateInternalizeActionArgs;
exports.validateOptionalOutpointString = validateOptionalOutpointString;
exports.validateOutpointString = validateOutpointString;
exports.validateRelinquishOutputArgs = validateRelinquishOutputArgs;
exports.validateRelinquishCertificateArgs = validateRelinquishCertificateArgs;
exports.validateListCertificatesArgs = validateListCertificatesArgs;
exports.validateAcquireCertificateArgs = validateAcquireCertificateArgs;
exports.validateAcquireIssuanceCertificateArgs = validateAcquireIssuanceCertificateArgs;
exports.validateAcquireDirectCertificateArgs = validateAcquireDirectCertificateArgs;
exports.validateProveCertificateArgs = validateProveCertificateArgs;
exports.validateDiscoverByIdentityKeyArgs = validateDiscoverByIdentityKeyArgs;
exports.validateDiscoverByAttributesArgs = validateDiscoverByAttributesArgs;
exports.validateListOutputsArgs = validateListOutputsArgs;
exports.validateListActionsArgs = validateListActionsArgs;
const sdk_1 = require("@bsv/sdk");
const index_client_1 = require("../index.client");
function parseWalletOutpoint(outpoint) {
    const [txid, vout] = outpoint.split('.');
    return { txid, vout: Number(vout) };
}
function defaultTrue(v) {
    return v !== null && v !== void 0 ? v : true;
}
function defaultFalse(v) {
    return v !== null && v !== void 0 ? v : false;
}
function defaultZero(v) {
    return v !== null && v !== void 0 ? v : 0;
}
function default0xffffffff(v) {
    return v !== null && v !== void 0 ? v : 0xffffffff;
}
function defaultOne(v) {
    return v !== null && v !== void 0 ? v : 1;
}
function defaultEmpty(v) {
    return v !== null && v !== void 0 ? v : [];
}
function validateOptionalStringLength(s, name, min, max) {
    if (s === undefined)
        return undefined;
    return validateStringLength(s, name, min, max);
}
function validateSatoshis(v, name, min) {
    if (v === undefined || !Number.isInteger(v) || v < 0 || v > 21e14)
        throw new index_client_1.sdk.WERR_INVALID_PARAMETER(name, 'a valid number of satoshis');
    if (min !== undefined && v < min)
        throw new index_client_1.sdk.WERR_INVALID_PARAMETER(name, `at least ${min} satoshis.`);
    return v;
}
function validateOptionalInteger(v, name, min, max) {
    if (v === undefined)
        return undefined;
    return validateInteger(v, name, undefined, min, max);
}
function validateInteger(v, name, defaultValue, min, max) {
    if (v === undefined) {
        if (defaultValue !== undefined)
            return defaultValue;
        throw new index_client_1.sdk.WERR_INVALID_PARAMETER(name, 'a valid integer');
    }
    if (!Number.isInteger(v))
        throw new index_client_1.sdk.WERR_INVALID_PARAMETER(name, 'an integer');
    v = Number(v);
    if (min !== undefined && v < min)
        throw new index_client_1.sdk.WERR_INVALID_PARAMETER(name, `at least ${min} length.`);
    if (max !== undefined && v > max)
        throw new index_client_1.sdk.WERR_INVALID_PARAMETER(name, `no more than ${max} length.`);
    return v;
}
function validatePositiveIntegerOrZero(v, name) {
    return validateInteger(v, name, 0, 0);
}
function validateStringLength(s, name, min, max) {
    const bytes = sdk_1.Utils.toArray(s, 'utf8').length;
    if (min !== undefined && bytes < min)
        throw new index_client_1.sdk.WERR_INVALID_PARAMETER(name, `at least ${min} length.`);
    if (max !== undefined && bytes > max)
        throw new index_client_1.sdk.WERR_INVALID_PARAMETER(name, `no more than ${max} length.`);
    return s;
}
function validateOptionalBasket(s) {
    if (s === undefined)
        return undefined;
    return validateBasket(s);
}
function validateBasket(s) {
    return validateIdentifier(s, 'basket', 1, 300);
}
function validateLabel(s) {
    return validateIdentifier(s, 'label', 1, 300);
}
function validateTag(s) {
    return validateIdentifier(s, 'tag', 1, 300);
}
function validateIdentifier(s, name, min, max) {
    s = s.trim().toLowerCase();
    const bytes = sdk_1.Utils.toArray(s, 'utf8').length;
    if (min !== undefined && bytes < min)
        throw new index_client_1.sdk.WERR_INVALID_PARAMETER(name, `at least ${min} length.`);
    if (max !== undefined && bytes > max)
        throw new index_client_1.sdk.WERR_INVALID_PARAMETER(name, `no more than ${max} length.`);
    return s;
}
function validateOptionalBase64String(s, name, min, max) {
    if (s === undefined)
        return undefined;
    return validateBase64String(s, name, min, max);
}
function validateBase64String(s, name, min, max) {
    // Remove any whitespace and check if the string length is valid for Base64
    s = s.trim();
    const base64Regex = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/;
    const paddingMatch = /=+$/.exec(s);
    const paddingCount = paddingMatch ? paddingMatch[0].length : 0;
    if (paddingCount > 2 || (s.length % 4 !== 0 && paddingCount !== 0) || !base64Regex.test(s)) {
        throw new index_client_1.sdk.WERR_INVALID_PARAMETER(name, `balid base64 string`);
    }
    const bytes = sdk_1.Utils.toArray(s, 'base64').length;
    if (min !== undefined && bytes < min)
        throw new index_client_1.sdk.WERR_INVALID_PARAMETER(name, `at least ${min} length.`);
    if (max !== undefined && bytes > max)
        throw new index_client_1.sdk.WERR_INVALID_PARAMETER(name, `no more than ${max} length.`);
    return s;
}
function validateOptionalHexString(s, name, min, max) {
    if (s === undefined)
        return undefined;
    return validateHexString(s, name, min, max);
}
/**
 * @param s
 * @param name
 * @param min if valid, string length minimum (not bytes)
 * @param max if valid, string length maximum (not bytes)
 * @returns
 */
function validateHexString(s, name, min, max) {
    s = s.trim().toLowerCase();
    if (s.length % 2 === 1)
        throw new index_client_1.sdk.WERR_INVALID_PARAMETER(name, `even length, not ${s.length}.`);
    const hexRegex = /^[0-9A-Fa-f]+$/;
    if (!hexRegex.test(s))
        throw new index_client_1.sdk.WERR_INVALID_PARAMETER(name, `hexadecimal string.`);
    if (min !== undefined && s.length < min)
        throw new index_client_1.sdk.WERR_INVALID_PARAMETER(name, `at least ${min} length.`);
    if (max !== undefined && s.length > max)
        throw new index_client_1.sdk.WERR_INVALID_PARAMETER(name, `no more than ${max} length.`);
    return s;
}
function isHexString(s) {
    s = s.trim();
    if (s.length % 2 === 1)
        return false;
    const hexRegex = /^[0-9A-Fa-f]+$/;
    if (!hexRegex.test(s))
        return false;
    return true;
}
function validateCreateActionInput(i) {
    var _a;
    if (i.unlockingScript === undefined && i.unlockingScriptLength === undefined)
        throw new index_client_1.sdk.WERR_INVALID_PARAMETER('unlockingScript, unlockingScriptLength', `at least one valid value.`);
    const unlockingScript = validateOptionalHexString(i.unlockingScript, 'unlockingScript');
    const unlockingScriptLength = (_a = i.unlockingScriptLength) !== null && _a !== void 0 ? _a : unlockingScript.length / 2;
    if (unlockingScript && unlockingScriptLength !== unlockingScript.length / 2)
        throw new index_client_1.sdk.WERR_INVALID_PARAMETER('unlockingScriptLength', `length unlockingScript if both valid.`);
    const vi = {
        outpoint: parseWalletOutpoint(i.outpoint),
        inputDescription: validateStringLength(i.inputDescription, 'inputDescription', 5, 2000),
        unlockingScript,
        unlockingScriptLength,
        sequenceNumber: default0xffffffff(i.sequenceNumber)
    };
    return vi;
}
function validateCreateActionOutput(o) {
    const vo = {
        lockingScript: validateHexString(o.lockingScript, 'lockingScript'),
        satoshis: validateSatoshis(o.satoshis, 'satoshis'),
        outputDescription: validateStringLength(o.outputDescription, 'outputDescription', 5, 2000),
        basket: validateOptionalBasket(o.basket),
        customInstructions: o.customInstructions,
        tags: defaultEmpty(o.tags).map(t => validateTag(t))
    };
    return vo;
}
/**
 * Set all default true/false booleans to true or false if undefined.
 * Set all possibly undefined numbers to their default values.
 * Set all possibly undefined arrays to empty arrays.
 * Convert string outpoints to `{ txid: string, vout: number }`
 */
function validateCreateActionOptions(options) {
    const o = options || {};
    const vo = {
        signAndProcess: defaultTrue(o.signAndProcess),
        acceptDelayedBroadcast: defaultTrue(o.acceptDelayedBroadcast),
        knownTxids: defaultEmpty(o.knownTxids),
        returnTXIDOnly: defaultFalse(o.returnTXIDOnly),
        noSend: defaultFalse(o.noSend),
        noSendChange: defaultEmpty(o.noSendChange).map(nsc => parseWalletOutpoint(nsc)),
        sendWith: defaultEmpty(o.sendWith),
        randomizeOutputs: defaultTrue(o.randomizeOutputs)
    };
    return vo;
}
function validateCreateActionArgs(args) {
    var _a;
    const vargs = {
        description: validateStringLength(args.description, 'description', 5, 2000),
        inputBEEF: args.inputBEEF,
        inputs: defaultEmpty(args.inputs).map(i => validateCreateActionInput(i)),
        outputs: defaultEmpty(args.outputs).map(o => validateCreateActionOutput(o)),
        lockTime: defaultZero(args.lockTime),
        version: defaultOne(args.version),
        labels: defaultEmpty((_a = args.labels) === null || _a === void 0 ? void 0 : _a.map(l => validateLabel(l))),
        options: validateCreateActionOptions(args.options),
        isSendWith: false,
        isDelayed: false,
        isNoSend: false,
        isNewTx: false,
        isRemixChange: false,
        isSignAction: false,
        randomVals: undefined,
        includeAllSourceTransactions: false
    };
    vargs.isSendWith = vargs.options.sendWith.length > 0;
    vargs.isRemixChange = !vargs.isSendWith && vargs.inputs.length === 0 && vargs.outputs.length === 0;
    vargs.isNewTx = vargs.isRemixChange || vargs.inputs.length > 0 || vargs.outputs.length > 0;
    vargs.isSignAction =
        vargs.isNewTx && (vargs.options.signAndProcess === false || vargs.inputs.some(i => i.unlockingScript === undefined));
    vargs.isDelayed = vargs.options.acceptDelayedBroadcast;
    vargs.isNoSend = vargs.options.noSend;
    return vargs;
}
/**
 * Set all default true/false booleans to true or false if undefined.
 * Set all possibly undefined numbers to their default values.
 * Set all possibly undefined arrays to empty arrays.
 * Convert string outpoints to `{ txid: string, vout: number }`
 */
function validateSignActionOptions(options) {
    const o = options || {};
    const vo = {
        acceptDelayedBroadcast: defaultTrue(o.acceptDelayedBroadcast),
        returnTXIDOnly: defaultFalse(o.returnTXIDOnly),
        noSend: defaultFalse(o.noSend),
        sendWith: defaultEmpty(o.sendWith)
    };
    return vo;
}
function validateSignActionArgs(args) {
    const vargs = {
        spends: args.spends,
        reference: args.reference,
        options: validateSignActionOptions(args.options),
        isSendWith: false,
        isDelayed: false,
        isNoSend: false,
        isNewTx: true,
        isRemixChange: false
    };
    vargs.isSendWith = vargs.options.sendWith.length > 0;
    vargs.isDelayed = vargs.options.acceptDelayedBroadcast;
    vargs.isNoSend = vargs.options.noSend;
    return vargs;
}
function validateAbortActionArgs(args) {
    const vargs = {
        reference: validateBase64String(args.reference, 'reference')
    };
    return vargs;
}
function validateWalletPayment(args) {
    if (args === undefined)
        return undefined;
    const v = {
        derivationPrefix: validateBase64String(args.derivationPrefix, 'derivationPrefix'),
        derivationSuffix: validateBase64String(args.derivationSuffix, 'derivationSuffix'),
        senderIdentityKey: validateHexString(args.senderIdentityKey, 'senderIdentityKey')
    };
    return v;
}
function validateBasketInsertion(args) {
    if (args === undefined)
        return undefined;
    const v = {
        basket: validateBasket(args.basket),
        customInstructions: validateOptionalStringLength(args.customInstructions, 'customInstructions', 0, 1000), // TODO: real max??
        tags: defaultEmpty(args.tags).map(t => validateTag(t))
    };
    return v;
}
function validateInternalizeOutput(args) {
    if (args.protocol !== 'basket insertion' && args.protocol !== 'wallet payment')
        throw new index_client_1.sdk.WERR_INVALID_PARAMETER('protocol', `'basket insertion' or 'wallet payment'`);
    const v = {
        outputIndex: validatePositiveIntegerOrZero(args.outputIndex, 'outputIndex'),
        protocol: args.protocol,
        paymentRemittance: validateWalletPayment(args.paymentRemittance),
        insertionRemittance: validateBasketInsertion(args.insertionRemittance)
    };
    return v;
}
function validateOriginator(s) {
    if (s === undefined)
        return undefined;
    s = s.trim().toLowerCase();
    validateStringLength(s, 'originator', 1, 250);
    const sps = s.split('.');
    for (const sp of sps) {
        validateStringLength(sp, 'originator part', 1, 63);
    }
}
function validateInternalizeActionArgs(args) {
    const vargs = {
        tx: args.tx,
        outputs: args.outputs.map(o => validateInternalizeOutput(o)),
        description: validateStringLength(args.description, 'description', 5, 2000),
        labels: (args.labels || []).map(t => validateLabel(t)),
        seekPermission: defaultTrue(args.seekPermission)
    };
    try {
        const beef = sdk_1.Beef.fromBinary(vargs.tx);
        if (beef.txs.length < 1)
            throw new index_client_1.sdk.WERR_INVALID_PARAMETER('tx', `at least one transaction to internalize an output from`);
    }
    catch (_a) {
        throw new index_client_1.sdk.WERR_INVALID_PARAMETER('tx', `valid with at least one transaction to internalize an output from`);
    }
    if (vargs.outputs.length < 1)
        throw new index_client_1.sdk.WERR_INVALID_PARAMETER('outputs', `at least one output to internalize from the transaction`);
    return vargs;
}
function validateOptionalOutpointString(outpoint, name) {
    if (outpoint === undefined)
        return undefined;
    return validateOutpointString(outpoint, name);
}
function validateOutpointString(outpoint, name) {
    const s = outpoint.split('.');
    if (s.length !== 2 || !Number.isInteger(Number(s[1])))
        throw new index_client_1.sdk.WERR_INVALID_PARAMETER(name, `txid as hex string and numeric output index joined with '.'`);
    const txid = validateHexString(s[0], `${name} txid`, undefined, 64);
    const vout = validatePositiveIntegerOrZero(Number(s[1]), `${name} vout`);
    return `${txid}.${vout}`;
}
function validateRelinquishOutputArgs(args) {
    const vargs = {
        basket: validateBasket(args.basket),
        output: validateOutpointString(args.output, 'output')
    };
    return vargs;
}
function validateRelinquishCertificateArgs(args) {
    const vargs = {
        type: validateBase64String(args.type, 'type'),
        serialNumber: validateBase64String(args.serialNumber, 'serialNumber'),
        certifier: validateHexString(args.certifier, 'certifier')
    };
    return vargs;
}
function validateListCertificatesArgs(args) {
    const vargs = {
        certifiers: defaultEmpty(args.certifiers.map(c => validateHexString(c.trim(), 'certifiers'))),
        types: defaultEmpty(args.types.map(t => validateBase64String(t.trim(), 'types'))),
        limit: validateInteger(args.limit, 'limit', 10, 1, 10000),
        offset: validatePositiveIntegerOrZero(defaultZero(args.offset), 'offset'),
        privileged: defaultFalse(args.privileged),
        privilegedReason: validateOptionalStringLength(args.privilegedReason, 'privilegedReason', 5, 50),
        partial: undefined
    };
    return vargs;
}
function validateCertificateFields(fields) {
    for (const fieldName of Object.keys(fields)) {
        validateStringLength(fieldName, 'field name', 1, 50);
    }
    return fields;
}
function validateKeyringRevealer(kr, name) {
    if (kr === 'certifier')
        return kr;
    return validateHexString(kr, name);
}
function validateOptionalKeyringRevealer(kr, name) {
    if (kr === undefined)
        return undefined;
    return validateKeyringRevealer(kr, name);
}
function validateKeyringForSubject(kr, name) {
    for (const fn of Object.keys(kr)) {
        validateStringLength(fn, `${name} field name`, 1, 50);
        validateBase64String(kr[fn], `${name} field value`);
    }
    return kr;
}
function validateOptionalKeyringForSubject(kr, name) {
    if (kr === undefined)
        return undefined;
    return validateKeyringForSubject(kr, name);
}
/**
 *
 * @param args
 * @param subject Must be valid for "direct" `acquisitionProtocol`. public key of the certificate subject.
 * @returns
 */
async function validateAcquireCertificateArgs(args) {
    const vargs = {
        acquisitionProtocol: args.acquisitionProtocol,
        type: validateBase64String(args.type, 'type'),
        serialNumber: validateOptionalBase64String(args.serialNumber, 'serialNumber'),
        certifier: validateHexString(args.certifier, 'certifier'),
        revocationOutpoint: validateOptionalOutpointString(args.revocationOutpoint, 'revocationOutpoint'),
        fields: validateCertificateFields(args.fields),
        signature: validateOptionalHexString(args.signature, 'signature'),
        certifierUrl: args.certifierUrl,
        keyringRevealer: validateOptionalKeyringRevealer(args.keyringRevealer, 'keyringRevealer'),
        keyringForSubject: validateOptionalKeyringForSubject(args.keyringForSubject, 'keyringForSubject'),
        privileged: defaultFalse(args.privileged),
        privilegedReason: validateOptionalStringLength(args.privilegedReason, 'privilegedReason', 5, 50)
    };
    if (vargs.privileged && !vargs.privilegedReason)
        throw new index_client_1.sdk.WERR_INVALID_PARAMETER('privilegedReason', `valid when 'privileged' is true `);
    if (vargs.acquisitionProtocol === 'direct') {
        if (!vargs.serialNumber)
            throw new index_client_1.sdk.WERR_INVALID_PARAMETER('serialNumber', 'valid when acquisitionProtocol is "direct"');
        if (!vargs.signature)
            throw new index_client_1.sdk.WERR_INVALID_PARAMETER('signature', 'valid when acquisitionProtocol is "direct"');
        if (!vargs.revocationOutpoint)
            throw new index_client_1.sdk.WERR_INVALID_PARAMETER('revocationOutpoint', 'valid when acquisitionProtocol is "direct"');
    }
    return vargs;
}
function validateAcquireIssuanceCertificateArgs(args) {
    if (args.acquisitionProtocol !== 'issuance')
        throw new index_client_1.sdk.WERR_INTERNAL('Only acquire certificate via issuance requests allowed here.');
    if (args.serialNumber)
        throw new index_client_1.sdk.WERR_INVALID_PARAMETER('serialNumber', 'valid when acquisitionProtocol is "direct"');
    if (args.signature)
        throw new index_client_1.sdk.WERR_INVALID_PARAMETER('signature', 'valid when acquisitionProtocol is "direct"');
    if (args.revocationOutpoint)
        throw new index_client_1.sdk.WERR_INVALID_PARAMETER('revocationOutpoint', 'valid when acquisitionProtocol is "direct"');
    if (args.keyringRevealer)
        throw new index_client_1.sdk.WERR_INVALID_PARAMETER('keyringRevealer', 'valid when acquisitionProtocol is "direct"');
    if (args.keyringForSubject)
        throw new index_client_1.sdk.WERR_INVALID_PARAMETER('keyringForSubject', 'valid when acquisitionProtocol is "direct"');
    if (!args.certifierUrl)
        throw new index_client_1.sdk.WERR_INVALID_PARAMETER('certifierUrl', 'valid when acquisitionProtocol is "issuance"');
    if (args.privileged && !args.privilegedReason)
        throw new index_client_1.sdk.WERR_INVALID_PARAMETER('privilegedReason', `valid when 'privileged' is true `);
    const vargs = {
        type: validateBase64String(args.type, 'type'),
        certifier: validateHexString(args.certifier, 'certifier'),
        certifierUrl: args.certifierUrl,
        fields: validateCertificateFields(args.fields),
        privileged: defaultFalse(args.privileged),
        privilegedReason: validateOptionalStringLength(args.privilegedReason, 'privilegedReason', 5, 50),
        subject: ''
    };
    return vargs;
}
function validateAcquireDirectCertificateArgs(args) {
    if (args.acquisitionProtocol !== 'direct')
        throw new index_client_1.sdk.WERR_INTERNAL('Only acquire direct certificate requests allowed here.');
    if (!args.serialNumber)
        throw new index_client_1.sdk.WERR_INVALID_PARAMETER('serialNumber', 'valid when acquisitionProtocol is "direct"');
    if (!args.signature)
        throw new index_client_1.sdk.WERR_INVALID_PARAMETER('signature', 'valid when acquisitionProtocol is "direct"');
    if (!args.revocationOutpoint)
        throw new index_client_1.sdk.WERR_INVALID_PARAMETER('revocationOutpoint', 'valid when acquisitionProtocol is "direct"');
    if (!args.keyringRevealer)
        throw new index_client_1.sdk.WERR_INVALID_PARAMETER('keyringRevealer', 'valid when acquisitionProtocol is "direct"');
    if (!args.keyringForSubject)
        throw new index_client_1.sdk.WERR_INVALID_PARAMETER('keyringForSubject', 'valid when acquisitionProtocol is "direct"');
    if (args.privileged && !args.privilegedReason)
        throw new index_client_1.sdk.WERR_INVALID_PARAMETER('privilegedReason', `valid when 'privileged' is true `);
    const vargs = {
        type: validateBase64String(args.type, 'type'),
        serialNumber: validateBase64String(args.serialNumber, 'serialNumber'),
        certifier: validateHexString(args.certifier, 'certifier'),
        revocationOutpoint: validateOutpointString(args.revocationOutpoint, 'revocationOutpoint'),
        fields: validateCertificateFields(args.fields),
        signature: validateHexString(args.signature, 'signature'),
        keyringRevealer: validateKeyringRevealer(args.keyringRevealer, 'keyringRevealer'),
        keyringForSubject: validateKeyringForSubject(args.keyringForSubject, 'keyringForSubject'),
        privileged: defaultFalse(args.privileged),
        privilegedReason: validateOptionalStringLength(args.privilegedReason, 'privilegedReason', 5, 50),
        subject: ''
    };
    return vargs;
}
function validateProveCertificateArgs(args) {
    if (args.privileged && !args.privilegedReason)
        throw new index_client_1.sdk.WERR_INVALID_PARAMETER('privilegedReason', `valid when 'privileged' is true `);
    const vargs = {
        type: validateOptionalBase64String(args.certificate.type, 'certificate.type'),
        serialNumber: validateOptionalBase64String(args.certificate.serialNumber, 'certificate.serialNumber'),
        certifier: validateOptionalHexString(args.certificate.certifier, 'certificate.certifier'),
        subject: validateOptionalHexString(args.certificate.subject, 'certificate.subject'),
        revocationOutpoint: validateOptionalOutpointString(args.certificate.revocationOutpoint, 'certificate.revocationOutpoint'),
        signature: validateOptionalHexString(args.certificate.signature, 'certificate.signature'),
        fieldsToReveal: defaultEmpty(args.fieldsToReveal).map(fieldName => validateStringLength(fieldName, `fieldsToReveal ${fieldName}`, 1, 50)),
        verifier: validateHexString(args.verifier, 'verifier'),
        privileged: defaultFalse(args.privileged),
        privilegedReason: validateOptionalStringLength(args.privilegedReason, 'privilegedReason', 5, 50)
    };
    return vargs;
}
function validateDiscoverByIdentityKeyArgs(args) {
    const vargs = {
        identityKey: validateHexString(args.identityKey, 'identityKey', 66, 66),
        limit: validateInteger(args.limit, 'limit', 10, 1, 10000),
        offset: validatePositiveIntegerOrZero(defaultZero(args.offset), 'offset'),
        seekPermission: defaultFalse(args.seekPermission)
    };
    return vargs;
}
function validateAttributes(attributes) {
    for (const fieldName of Object.keys(attributes)) {
        validateStringLength(fieldName, `field name ${fieldName}`, 1, 50);
    }
    return attributes;
}
function validateDiscoverByAttributesArgs(args) {
    const vargs = {
        attributes: validateAttributes(args.attributes),
        limit: validateInteger(args.limit, 'limit', 10, 1, 10000),
        offset: validatePositiveIntegerOrZero(defaultZero(args.offset), 'offset'),
        seekPermission: defaultFalse(args.seekPermission)
    };
    return vargs;
}
/**
 * @param {BasketStringUnder300Bytes} args.basket - Required. The associated basket name whose outputs should be listed.
 * @param {OutputTagStringUnder300Bytes[]} [args.tags] - Optional. Filter outputs based on these tags.
 * @param {'all' | 'any'} [args.tagQueryMode] - Optional. Filter mode, defining whether all or any of the tags must match. By default, any tag can match.
 * @param {'locking scripts' | 'entire transactions'} [args.include] - Optional. Whether to include locking scripts (with each output) or entire transactions (as aggregated BEEF, at the top level) in the result. By default, unless specified, neither are returned.
 * @param {BooleanDefaultFalse} [args.includeEntireTransactions] - Optional. Whether to include the entire transaction(s) in the result.
 * @param {BooleanDefaultFalse} [args.includeCustomInstructions] - Optional. Whether custom instructions should be returned in the result.
 * @param {BooleanDefaultFalse} [args.includeTags] - Optional. Whether the tags associated with the output should be returned.
 * @param {BooleanDefaultFalse} [args.includeLabels] - Optional. Whether the labels associated with the transaction containing the output should be returned.
 * @param {PositiveIntegerDefault10Max10000} [args.limit] - Optional limit on the number of outputs to return.
 * @param {number} [args.offset] - If positive or zero: Number of outputs to skip before starting to return results, oldest first.
 * If negative: Outputs are returned newest first and offset of -1 is the newest output.
 * When using negative offsets, caution is required as new outputs may be added between calls,
 * potentially causing outputs to be duplicated across calls.
 * @param {BooleanDefaultTrue} [args.seekPermission] — Optional. Whether to seek permission from the user for this operation if required. Default true, will return an error rather than proceed if set to false.
 */
function validateListOutputsArgs(args) {
    let tagQueryMode;
    if (args.tagQueryMode === undefined || args.tagQueryMode === 'any')
        tagQueryMode = 'any';
    else if (args.tagQueryMode === 'all')
        tagQueryMode = 'all';
    else
        throw new index_client_1.sdk.WERR_INVALID_PARAMETER('tagQueryMode', `undefined, 'any', or 'all'`);
    const vargs = {
        basket: validateStringLength(args.basket, 'basket', 1, 300),
        tags: (args.tags || []).map(t => validateStringLength(t, 'tag', 1, 300)),
        tagQueryMode,
        includeLockingScripts: args.include === 'locking scripts',
        includeTransactions: args.include === 'entire transactions',
        includeCustomInstructions: defaultFalse(args.includeCustomInstructions),
        includeTags: defaultFalse(args.includeTags),
        includeLabels: defaultFalse(args.includeLabels),
        limit: validateInteger(args.limit, 'limit', 10, 1, 10000),
        offset: validateInteger(args.offset, 'offset', 0, undefined, undefined),
        seekPermission: defaultTrue(args.seekPermission),
        knownTxids: []
    };
    return vargs;
}
/**
 * @param {LabelStringUnder300Bytes[]} args.labels - An array of labels used to filter actions.
 * @param {'any' | 'all'} [args.labelQueryMode] - Optional. Specifies how to match labels (default is any which matches any of the labels).
 * @param {BooleanDefaultFalse} [args.includeLabels] - Optional. Whether to include transaction labels in the result set.
 * @param {BooleanDefaultFalse} [args.includeInputs] - Optional. Whether to include input details in the result set.
 * @param {BooleanDefaultFalse} [args.includeInputSourceLockingScripts] - Optional. Whether to include input source locking scripts in the result set.
 * @param {BooleanDefaultFalse} [args.includeInputUnlockingScripts] - Optional. Whether to include input unlocking scripts in the result set.
 * @param {BooleanDefaultFalse} [args.includeOutputs] - Optional. Whether to include output details in the result set.
 * @param {BooleanDefaultFalse} [args.includeOutputLockingScripts] - Optional. Whether to include output locking scripts in the result set.
 * @param {PositiveIntegerDefault10Max10000} [args.limit] - Optional. The maximum number of transactions to retrieve.
 * @param {PositiveIntegerOrZero} [args.offset] - Optional. Number of transactions to skip before starting to return the results.
 * @param {BooleanDefaultTrue} [args.seekPermission] — Optional. Whether to seek permission from the user for this operation if required. Default true, will return an error rather than proceed if set to false.
 */
function validateListActionsArgs(args) {
    let labelQueryMode;
    if (args.labelQueryMode === undefined || args.labelQueryMode === 'any')
        labelQueryMode = 'any';
    else if (args.labelQueryMode === 'all')
        labelQueryMode = 'all';
    else
        throw new index_client_1.sdk.WERR_INVALID_PARAMETER('labelQueryMode', `undefined, 'any', or 'all'`);
    const vargs = {
        labels: (args.labels || []).map(t => validateLabel(t)),
        labelQueryMode,
        includeLabels: defaultFalse(args.includeLabels),
        includeInputs: defaultFalse(args.includeInputs),
        includeInputSourceLockingScripts: defaultFalse(args.includeInputSourceLockingScripts),
        includeInputUnlockingScripts: defaultFalse(args.includeInputUnlockingScripts),
        includeOutputs: defaultFalse(args.includeOutputs),
        includeOutputLockingScripts: defaultFalse(args.includeOutputLockingScripts),
        limit: validateInteger(args.limit, 'limit', 10, 1, 10000),
        offset: validateInteger(args.offset, 'offset', 0, 0),
        seekPermission: defaultTrue(args.seekPermission)
    };
    return vargs;
}
//# sourceMappingURL=validationHelpers.js.map