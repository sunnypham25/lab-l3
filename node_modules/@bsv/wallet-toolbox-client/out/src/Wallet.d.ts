import { AbortActionArgs, AbortActionResult, AcquireCertificateArgs, AcquireCertificateResult, AuthenticatedResult, Beef, BeefParty, CreateActionArgs, CreateActionResult, CreateHmacArgs, CreateHmacResult, CreateSignatureArgs, CreateSignatureResult, DiscoverByAttributesArgs, DiscoverByIdentityKeyArgs, DiscoverCertificatesResult, GetHeaderArgs, GetHeaderResult, GetHeightResult, GetNetworkResult, GetPublicKeyArgs, GetPublicKeyResult, GetVersionResult, InternalizeActionArgs, InternalizeActionResult, ListActionsArgs, ListActionsResult, ListCertificatesArgs, ListCertificatesResult, ListOutputsArgs, ListOutputsResult, OriginatorDomainNameStringUnder250Bytes, ProtoWallet, ProveCertificateArgs, ProveCertificateResult, PubKeyHex, RelinquishCertificateArgs, RelinquishCertificateResult, RelinquishOutputArgs, RelinquishOutputResult, RevealCounterpartyKeyLinkageArgs, RevealCounterpartyKeyLinkageResult, RevealSpecificKeyLinkageArgs, RevealSpecificKeyLinkageResult, SignActionArgs, SignActionResult, Transaction as BsvTransaction, TrustSelf, VerifyHmacArgs, VerifyHmacResult, VerifySignatureArgs, VerifySignatureResult, WalletDecryptArgs, WalletDecryptResult, WalletEncryptArgs, WalletEncryptResult, WalletInterface, LookupResolver, AtomicBEEF, BEEF, KeyDeriverApi } from '@bsv/sdk';
import * as sdk from './sdk';
import { WalletSettingsManager } from './WalletSettingsManager';
import { WalletStorageManager } from './storage/WalletStorageManager';
import { Monitor } from './monitor/Monitor';
import { WalletSigner } from './signer/WalletSigner';
export interface WalletArgs {
    chain: sdk.Chain;
    keyDeriver: KeyDeriverApi;
    storage: WalletStorageManager;
    services?: sdk.WalletServices;
    monitor?: Monitor;
    privilegedKeyManager?: sdk.PrivilegedKeyManager;
    settingsManager?: WalletSettingsManager;
    lookupResolver?: LookupResolver;
}
export declare class Wallet implements WalletInterface, ProtoWallet {
    chain: sdk.Chain;
    keyDeriver: KeyDeriverApi;
    storage: WalletStorageManager;
    settingsManager: WalletSettingsManager;
    lookupResolver: LookupResolver;
    services?: sdk.WalletServices;
    monitor?: Monitor;
    identityKey: string;
    /**
     * The wallet creates a `BeefParty` when it is created.
     * All the Beefs that pass through the wallet are merged into this beef.
     * Thus what it contains at any time is the union of all transactions and proof data processed.
     * The class `BeefParty` derives from `Beef`, adding the ability to track the source of merged data.
     *
     * This allows it to generate beefs to send to a particular “party” (storage or the user)
     * that includes “txid only proofs” for transactions they already know about.
     * Over time, this allows an active wallet to drastically reduce the amount of data transmitted.
     */
    beef: BeefParty;
    /**
     * If true, signableTransactions will include sourceTransaction for each input,
     * including those that do not require signature and those that were also contained
     * in the inputBEEF.
     */
    includeAllSourceTransactions: boolean;
    /**
     * If true, txids that are known to the wallet's party beef do not need to be returned from storage.
     */
    autoKnownTxids: boolean;
    /**
     * If true, beefs returned to the user may contain txidOnly transactions.
     */
    returnTxidOnly: boolean;
    trustSelf?: TrustSelf;
    userParty: string;
    proto: ProtoWallet;
    privilegedKeyManager?: sdk.PrivilegedKeyManager;
    pendingSignActions: Record<string, PendingSignAction>;
    /**
     * For repeatability testing, set to an array of random numbers from [0..1).
     */
    randomVals?: number[];
    constructor(argsOrSigner: WalletArgs | WalletSigner, services?: sdk.WalletServices, monitor?: Monitor, privilegedKeyManager?: sdk.PrivilegedKeyManager);
    destroy(): Promise<void>;
    getClientChangeKeyPair(): sdk.KeyPair;
    getIdentityKey(): Promise<PubKeyHex>;
    getPublicKey(args: GetPublicKeyArgs, originator?: OriginatorDomainNameStringUnder250Bytes): Promise<GetPublicKeyResult>;
    revealCounterpartyKeyLinkage(args: RevealCounterpartyKeyLinkageArgs, originator?: OriginatorDomainNameStringUnder250Bytes): Promise<RevealCounterpartyKeyLinkageResult>;
    revealSpecificKeyLinkage(args: RevealSpecificKeyLinkageArgs, originator?: OriginatorDomainNameStringUnder250Bytes): Promise<RevealSpecificKeyLinkageResult>;
    encrypt(args: WalletEncryptArgs, originator?: OriginatorDomainNameStringUnder250Bytes): Promise<WalletEncryptResult>;
    decrypt(args: WalletDecryptArgs, originator?: OriginatorDomainNameStringUnder250Bytes): Promise<WalletDecryptResult>;
    createHmac(args: CreateHmacArgs, originator?: OriginatorDomainNameStringUnder250Bytes): Promise<CreateHmacResult>;
    verifyHmac(args: VerifyHmacArgs, originator?: OriginatorDomainNameStringUnder250Bytes): Promise<VerifyHmacResult>;
    createSignature(args: CreateSignatureArgs, originator?: OriginatorDomainNameStringUnder250Bytes): Promise<CreateSignatureResult>;
    verifySignature(args: VerifySignatureArgs, originator?: OriginatorDomainNameStringUnder250Bytes): Promise<VerifySignatureResult>;
    getServices(): sdk.WalletServices;
    /**
     * @returns the full list of txids whose validity this wallet claims to know.
     *
     * @param newKnownTxids Optional. Additional new txids known to be valid by the caller to be merged.
     */
    getKnownTxids(newKnownTxids?: string[]): string[];
    getStorageIdentity(): sdk.StorageIdentity;
    private validateAuthAndArgs;
    listActions(args: ListActionsArgs, originator?: OriginatorDomainNameStringUnder250Bytes): Promise<ListActionsResult>;
    get storageParty(): string;
    listOutputs(args: ListOutputsArgs, originator?: OriginatorDomainNameStringUnder250Bytes): Promise<ListOutputsResult>;
    listCertificates(args: ListCertificatesArgs, originator?: OriginatorDomainNameStringUnder250Bytes): Promise<ListCertificatesResult>;
    acquireCertificate(args: AcquireCertificateArgs, originator?: OriginatorDomainNameStringUnder250Bytes): Promise<AcquireCertificateResult>;
    relinquishCertificate(args: RelinquishCertificateArgs, originator?: OriginatorDomainNameStringUnder250Bytes): Promise<RelinquishCertificateResult>;
    proveCertificate(args: ProveCertificateArgs, originator?: OriginatorDomainNameStringUnder250Bytes): Promise<ProveCertificateResult>;
    discoverByIdentityKey(args: DiscoverByIdentityKeyArgs, originator?: OriginatorDomainNameStringUnder250Bytes): Promise<DiscoverCertificatesResult>;
    discoverByAttributes(args: DiscoverByAttributesArgs, originator?: OriginatorDomainNameStringUnder250Bytes): Promise<DiscoverCertificatesResult>;
    verifyReturnedTxidOnly(beef: Beef, knownTxids?: string[]): Beef;
    verifyReturnedTxidOnlyAtomicBEEF(beef: AtomicBEEF, knownTxids?: string[]): AtomicBEEF;
    verifyReturnedTxidOnlyBEEF(beef: BEEF): BEEF;
    createAction(args: CreateActionArgs, originator?: OriginatorDomainNameStringUnder250Bytes): Promise<CreateActionResult>;
    signAction(args: SignActionArgs, originator?: OriginatorDomainNameStringUnder250Bytes): Promise<SignActionResult>;
    internalizeAction(args: InternalizeActionArgs, originator?: OriginatorDomainNameStringUnder250Bytes): Promise<InternalizeActionResult>;
    abortAction(args: AbortActionArgs, originator?: OriginatorDomainNameStringUnder250Bytes): Promise<AbortActionResult>;
    relinquishOutput(args: RelinquishOutputArgs, originator?: OriginatorDomainNameStringUnder250Bytes): Promise<RelinquishOutputResult>;
    isAuthenticated(args: {}, originator?: OriginatorDomainNameStringUnder250Bytes): Promise<AuthenticatedResult>;
    waitForAuthentication(args: {}, originator?: OriginatorDomainNameStringUnder250Bytes): Promise<AuthenticatedResult>;
    getHeight(args: {}, originator?: OriginatorDomainNameStringUnder250Bytes): Promise<GetHeightResult>;
    getHeaderForHeight(args: GetHeaderArgs, originator?: OriginatorDomainNameStringUnder250Bytes): Promise<GetHeaderResult>;
    getNetwork(args: {}, originator?: OriginatorDomainNameStringUnder250Bytes): Promise<GetNetworkResult>;
    getVersion(args: {}, originator?: OriginatorDomainNameStringUnder250Bytes): Promise<GetVersionResult>;
    /**
     * Transfer all possible satoshis held by this wallet to `toWallet`.
     *
     * @param toWallet wallet which will receive this wallet's satoshis.
     */
    sweepTo(toWallet: Wallet): Promise<void>;
    /**
     * Uses `listOutputs` to iterate over chunks of up to 1000 outputs to
     * compute the sum of output satoshis.
     *
     * @param {string} basket - Optional. Defaults to 'default', the wallet change basket.
     * @returns {sdk.WalletBalance} total sum of output satoshis and utxo details (satoshis and outpoints)
     */
    balanceAndUtxos(basket?: string): Promise<sdk.WalletBalance>;
    /**
     * Uses `listOutputs` special operation to compute the total value (of satoshis) for
     * all spendable outputs in the 'default' basket.
     *
     * @returns {number} sum of output satoshis
     */
    balance(): Promise<number>;
    /**
     * Uses `listOutputs` special operation to review the spendability via `Services` of
     * outputs currently considered spendable. Returns the outputs that fail to verify.
     *
     * Ignores the `limit` and `offset` properties.
     *
     * @param all Defaults to false. If false, only change outputs ('default' basket) are reviewed. If true, all spendable outputs are reviewed.
     * @param release Defaults to false. If true, sets outputs that fail to verify to un-spendable (spendable: false)
     * @param optionalArgs Optional. Additional tags will constrain the outputs processed.
     * @returns outputs which are/where considered spendable but currently fail to verify as spendable.
     */
    reviewSpendableOutputs(all?: boolean, release?: boolean, optionalArgs?: Partial<ListOutputsArgs>): Promise<ListOutputsResult>;
    /**
     * Uses `listOutputs` special operation to update the 'default' basket's automatic
     * change generation parameters.
     *
     * @param count target number of change UTXOs to maintain.
     * @param satoshis target value for new change outputs.
     */
    setWalletChangeParams(count: number, satoshis: number): Promise<void>;
    /**
     * Uses `listActions` special operation to return only actions with status 'nosend'.
     *
     * @param abort Defaults to false. If true, runs `abortAction` on each 'nosend' action.
     * @returns {ListActionsResult} start `listActions` result restricted to 'nosend' (or 'failed' if aborted) actions.
     */
    listNoSendActions(args: ListActionsArgs, abort?: boolean): Promise<ListActionsResult>;
    /**
     * Uses `listActions` special operation to return only actions with status 'failed'.
     *
     * @param unfail Defaults to false. If true, queues the action for attempted recovery.
     * @returns {ListActionsResult} start `listActions` result restricted to 'failed' status actions.
     */
    listFailedActions(args: ListActionsArgs, unfail?: boolean): Promise<ListActionsResult>;
}
export interface PendingStorageInput {
    vin: number;
    derivationPrefix: string;
    derivationSuffix: string;
    unlockerPubKey?: string;
    sourceSatoshis: number;
    lockingScript: string;
}
export interface PendingSignAction {
    reference: string;
    dcr: sdk.StorageCreateActionResult;
    args: sdk.ValidCreateActionArgs;
    tx: BsvTransaction;
    amount: number;
    pdi: PendingStorageInput[];
}
//# sourceMappingURL=Wallet.d.ts.map