import { Transaction as BsvTransaction, Beef, ChainTracker } from '@bsv/sdk';
import { sdk, TableOutput } from '../index.client';
import { ServiceCollection } from './ServiceCollection';
import { WhatsOnChain } from './providers/WhatsOnChain';
import { ARC } from './providers/ARC';
import { Bitails } from './providers/Bitails';
import { ServicesCallHistory } from '../sdk/WalletServices.interfaces';
export declare class Services implements sdk.WalletServices {
    static createDefaultOptions(chain: sdk.Chain): sdk.WalletServicesOptions;
    options: sdk.WalletServicesOptions;
    whatsonchain: WhatsOnChain;
    arcTaal: ARC;
    arcGorillaPool?: ARC;
    bitails: Bitails;
    getMerklePathServices: ServiceCollection<sdk.GetMerklePathService>;
    getRawTxServices: ServiceCollection<sdk.GetRawTxService>;
    postBeefServices: ServiceCollection<sdk.PostBeefService>;
    getUtxoStatusServices: ServiceCollection<sdk.GetUtxoStatusService>;
    getStatusForTxidsServices: ServiceCollection<sdk.GetStatusForTxidsService>;
    getScriptHashHistoryServices: ServiceCollection<sdk.GetScriptHashHistoryService>;
    updateFiatExchangeRateServices: ServiceCollection<sdk.UpdateFiatExchangeRateService>;
    chain: sdk.Chain;
    constructor(optionsOrChain: sdk.Chain | sdk.WalletServicesOptions);
    getServicesCallHistory(reset?: boolean): ServicesCallHistory;
    getChainTracker(): Promise<ChainTracker>;
    getBsvExchangeRate(): Promise<number>;
    getFiatExchangeRate(currency: 'USD' | 'GBP' | 'EUR', base?: 'USD' | 'GBP' | 'EUR'): Promise<number>;
    get getProofsCount(): number;
    get getRawTxsCount(): number;
    get postBeefServicesCount(): number;
    get getUtxoStatsCount(): number;
    getStatusForTxids(txids: string[], useNext?: boolean): Promise<sdk.GetStatusForTxidsResult>;
    /**
     * @param script Output script to be hashed for `getUtxoStatus` default `outputFormat`
     * @returns script hash in 'hashLE' format, which is the default.
     */
    hashOutputScript(script: string): string;
    isUtxo(output: TableOutput): Promise<boolean>;
    getUtxoStatus(output: string, outputFormat?: sdk.GetUtxoStatusOutputFormat, outpoint?: string, useNext?: boolean): Promise<sdk.GetUtxoStatusResult>;
    getScriptHashHistory(hash: string, useNext?: boolean): Promise<sdk.GetScriptHashHistoryResult>;
    postBeefMode: 'PromiseAll' | 'UntilSuccess';
    /**
     *
     * @param beef
     * @param chain
     * @returns
     */
    postBeef(beef: Beef, txids: string[]): Promise<sdk.PostBeefResult[]>;
    getRawTx(txid: string, useNext?: boolean): Promise<sdk.GetRawTxResult>;
    invokeChaintracksWithRetry<R>(method: () => Promise<R>): Promise<R>;
    getHeaderForHeight(height: number): Promise<number[]>;
    getHeight(): Promise<number>;
    hashToHeader(hash: string): Promise<sdk.BlockHeader>;
    getMerklePath(txid: string, useNext?: boolean): Promise<sdk.GetMerklePathResult>;
    targetCurrencies: string[];
    updateFiatExchangeRates(rates?: sdk.FiatExchangeRates, updateMsecs?: number): Promise<sdk.FiatExchangeRates>;
    nLockTimeIsFinal(tx: string | number[] | BsvTransaction | number): Promise<boolean>;
    getBeefForTxid(txid: string): Promise<Beef>;
}
export declare function validateScriptHash(output: string, outputFormat?: sdk.GetUtxoStatusOutputFormat): string;
/**
 * Serializes a block header as an 80 byte array.
 * The exact serialized format is defined in the Bitcoin White Paper
 * such that computing a double sha256 hash of the array computes
 * the block hash for the header.
 * @returns 80 byte array
 * @publicbody
 */
export declare function toBinaryBaseBlockHeader(header: sdk.BaseBlockHeader): number[];
//# sourceMappingURL=Services.d.ts.map