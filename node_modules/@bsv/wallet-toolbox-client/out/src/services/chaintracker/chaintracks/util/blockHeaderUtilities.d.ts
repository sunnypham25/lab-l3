import { BigNumber } from '@bsv/sdk';
import { BaseBlockHeader, BlockHeader } from '../Api/BlockHeaderApi';
import { Chain } from '../../../../sdk/types';
/**
 * Computes sha256 hash of file contents read as bytes with no encoding.
 * @param filepath Full filepath to file.
 * @param bufferSize Optional read buffer size to use. Defaults to 80,000 bytes.
 * @returns `{hash, length}` where `hash` is base64 string form of file hash and `length` is file length in bytes.
 */
/**
 * Validate headers contained in an array of bytes. The headers must be consecutive block headers, 80 bytes long,
 *  where the hash of each header equals the previousHash of the following header.
 * @param buffer Buffer of headers to be validated.
 * @param previousHash Expected previousHash of first header.
 * @param offset Optional starting offset within `buffer`.
 * @param count Optional number of headers to validate. Validates to end of buffer if missing.
 * @returns Header hash of last header validated or previousHash if there where none.
 */
export declare function validateBufferOfHeaders(buffer: number[], previousHash: string, offset?: number, count?: number): string;
/**
 * @param work chainWork as a BigNumber
 * @returns Converted chainWork value from BN to hex string of 32 bytes.
 */
export declare function workBNtoBuffer(work: BigNumber): string;
/**
 * Returns true if work1 is more work (greater than) work2
 */
export declare function isMoreWork(work1: string, work2: string): boolean;
/**
 * Add two Buffer encoded chainwork values
 * @returns Sum of work1 + work2 as Buffer encoded chainWork value
 */
export declare function addWork(work1: string, work2: string): string;
/**
 * Subtract Buffer encoded chainwork values
 * @returns work1 - work2 as Buffer encoded chainWork value
 */
export declare function subWork(work1: string, work2: string): string;
/**
 * Computes "target" value for 4 byte Bitcoin block header "bits" value.
 * @param bits number or converted from Buffer using `readUint32LE`
 * @returns 32 byte Buffer with "target" value
 */
export declare function convertBitsToTarget(bits: number | number[]): BigNumber;
/**
 * Computes "chainWork" value for 4 byte Bitcoin block header "bits" value.
 * @param bits number or converted from Buffer using `readUint32LE`
 * @returns 32 byte Buffer with "chainWork" value
 */
export declare function convertBitsToWork(bits: number | number[]): string;
export declare function deserializeBaseBlockHeaders(buffer: number[], offset?: number, count?: number | undefined): BaseBlockHeader[];
export declare function deserializeBlockHeaders(firstHeight: number, buffer: number[], offset?: number, count?: number | undefined): BlockHeader[];
/**
 * Extract an array of block hashes and of merkleRoots from a buffer of serialized block headers.
 * @param buffer
 */
export declare function extractHashesAndRoots(buffer: Buffer): {
    hashes: Buffer[];
    merkleRoots: Buffer[];
};
/**
 * Given a block header, ensures that its format is correct. This does not
 * check its difficulty or validity relative to the chain of headers.
 *
 * Throws on format errors.
 *
 * @param The header to validate
 *
 * @returns true if the header is correctly formatted
 */
export declare function validateHeaderFormat(header: BlockHeader): void;
/**
 * Ensures that a header has a valid proof-of-work
 * Requires chain is 'main'
 *
 * @param header The header to validate
 *
 * @returns true if the header is valid
 */
export declare function validateHeaderDifficulty(hash: Buffer, bits: number): boolean;
/**
 * Computes double sha256 hash of bitcoin block header
 * bytes are reversed to bigendian order
 *
 * If header is a Buffer, it is required to 80 bytes long
 * and in standard block header serialized encoding.
 *
 * @returns doule sha256 hash of header bytes reversed
 * @publicbody
 */
export declare function blockHash(header: BaseBlockHeader | number[]): string;
/**
 * Serializes a block header as an 80 byte Buffer.
 * The exact serialized format is defined in the Bitcoin White Paper
 * such that computing a double sha256 hash of the buffer computes
 * the block hash for the header.
 * @returns 80 byte Buffer
 * @publicbody
 */
export declare function serializeBlockHeader(header: BaseBlockHeader, buffer?: number[], offset?: number): number[];
/**
 * Deserialize a block header from an 80 byte buffer
 * @publicbody
 */
export declare function deserializeBlockHeader(buffer: number[], offset?: number): BaseBlockHeader;
/**
 * Returns the genesis block for the specified chain.
 * @publicbody
 */
export declare function genesisHeader(chain: Chain): BlockHeader;
/**
 * Returns the genesis block for the specified chain.
 * @publicbody
 */
export declare function genesisBuffer(chain: Chain): number[];
/**
 * Returns a copy of a Buffer with byte order reversed.
 * @returns new buffer with byte order reversed.
 * @publicbody
 */
export declare function swapByteOrder(buffer: number[]): number[];
/**
 * @param num a number value in the Uint32 value range
 * @param littleEndian true for little-endian byte order in Buffer
 * @returns four byte buffer with Uint32 number encoded
 * @publicbody
 */
export declare function convertUint32ToBuffer(n: number, littleEndian?: boolean): number[];
export declare function writeUInt32LE(n: number, a: number[], offset: number): number;
export declare function writeUInt32BE(n: number, a: number[], offset: number): number;
export declare function readUInt32LE(a: number[], offset: number): number;
export declare function readUInt32BE(a: number[], offset: number): number;
/**
 * @param buffer four byte buffer with Uint32 number encoded
 * @param littleEndian true for little-endian byte order in Buffer
 * @returns a number value in the Uint32 value range
 * @publicbody
 */
export declare function convertBufferToUint32(buffer: number[], littleEndian?: boolean): number;
//# sourceMappingURL=blockHeaderUtilities.d.ts.map