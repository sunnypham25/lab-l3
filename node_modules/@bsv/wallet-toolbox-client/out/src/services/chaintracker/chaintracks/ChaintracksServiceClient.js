"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChaintracksServiceClient = void 0;
/* eslint-disable @typescript-eslint/no-unused-vars */
const index_client_1 = require("../../../index.client");
/**
 * Connects to a ChaintracksService to implement 'ChaintracksClientApi'
 *
 */
class ChaintracksServiceClient {
    static createChaintracksServiceClientOptions() {
        const options = {
            useAuthrite: false
        };
        return options;
    }
    constructor(chain, serviceUrl, options) {
        this.chain = chain;
        this.serviceUrl = serviceUrl;
        this.options = options || ChaintracksServiceClient.createChaintracksServiceClientOptions();
    }
    async currentHeight() {
        return await this.getPresentHeight();
    }
    async isValidRootForHeight(root, height) {
        const r = await this.findHeaderForHeight(height);
        if (!r)
            return false;
        const isValid = root === (0, index_client_1.asString)(r.merkleRoot);
        return isValid;
    }
    async getJsonOrUndefined(path) {
        let e = undefined;
        for (let retry = 0; retry < 3; retry++) {
            try {
                const r = await fetch(`${this.serviceUrl}${path}`);
                const v = await r.json();
                if (v.status === 'success')
                    return v.value;
                else
                    e = new Error(JSON.stringify(v));
            }
            catch (eu) {
                e = eu;
            }
            if (e && e.name !== 'ECONNRESET')
                break;
        }
        if (e)
            throw e;
    }
    async getJson(path) {
        const r = await this.getJsonOrUndefined(path);
        if (r === undefined)
            throw new Error('Value was undefined. Requested object may not exist.');
        return r;
    }
    async postJsonVoid(path, params) {
        const headers = {};
        headers['Content-Type'] = 'application/json';
        const r = await fetch(`${this.serviceUrl}${path}`, {
            body: JSON.stringify(params),
            method: 'POST',
            headers
            //cache: 'no-cache',
        });
        try {
            const s = await r.json();
            if (s.status === 'success')
                return;
            throw new Error(JSON.stringify(s));
        }
        catch (e) {
            console.log(`Exception: ${JSON.stringify(e)}`);
            throw new Error(JSON.stringify(e));
        }
    }
    //
    // HTTP API FUNCTIONS
    //
    async addHeader(header) {
        const r = await this.postJsonVoid('/addHeaderHex', header);
        if (typeof r === 'string')
            throw new Error(r);
    }
    async startListening() {
        return await this.getJsonOrUndefined('/startListening');
    }
    async listening() {
        return await this.getJsonOrUndefined('/listening');
    }
    async getChain() {
        return this.chain;
        //return await this.getJson('/getChain')
    }
    async isListening() {
        return await this.getJson('/isListening');
    }
    async isSynchronized() {
        return await this.getJson('/isSynchronized');
    }
    async getPresentHeight() {
        return await this.getJson('/getPresentHeight');
    }
    async findChainTipHeader() {
        return await this.getJson('/findChainTipHeaderHex');
    }
    async findChainTipHashHex() {
        return await this.getJson('/findChainTipHashHex');
    }
    async getHeaders(height, count) {
        return await this.getJson(`/getHeaders?height=${height}&count=${count}`);
    }
    async findHeaderForHeight(height) {
        return await this.getJsonOrUndefined(`/findHeaderHexForHeight?height=${height}`);
    }
    async findChainWorkForBlockHash(hash) {
        return await this.getJsonOrUndefined(`/findChainWorkHexForBlockHash?hash=${(0, index_client_1.asString)(hash)}`);
    }
    async findHeaderForBlockHash(hash) {
        return await this.getJsonOrUndefined(`/findHeaderHexForBlockHash?hash=${(0, index_client_1.asString)(hash)}`);
    }
    async findHeaderForMerkleRoot(merkleRoot, height) {
        return await this.getJsonOrUndefined(`/findHeaderHexForMerkleRoot?root=${(0, index_client_1.asString)(merkleRoot)}&height=${height}`);
    }
}
exports.ChaintracksServiceClient = ChaintracksServiceClient;
//# sourceMappingURL=ChaintracksServiceClient.js.map