"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChaintracksChainTracker = void 0;
const index_client_1 = require("../../index.client");
const ChaintracksServiceClient_1 = require("./chaintracks/ChaintracksServiceClient");
class ChaintracksChainTracker {
    constructor(chain, chaintracks, options) {
        chain || (chain = 'main');
        this.chaintracks =
            chaintracks !== null && chaintracks !== void 0 ? chaintracks : new ChaintracksServiceClient_1.ChaintracksServiceClient(chain, `https://npm-registry.babbage.systems:808${chain === 'main' ? '4' : '3'}`);
        this.cache = {};
        this.options = options || {};
    }
    async currentHeight() {
        return await this.chaintracks.getPresentHeight();
    }
    async isValidRootForHeight(root, height) {
        const cachedRoot = this.cache[height];
        if (cachedRoot) {
            return cachedRoot === root;
        }
        let header;
        const retries = this.options.maxRetries || 3;
        let error = undefined;
        for (let tryCount = 1; tryCount <= retries; tryCount++) {
            try {
                header = await this.chaintracks.findHeaderForHeight(height);
                if (!header) {
                    return false;
                }
                break;
            }
            catch (eu) {
                error = index_client_1.sdk.WalletError.fromUnknown(eu);
                if (tryCount > retries) {
                    throw error;
                }
                await (0, index_client_1.wait)(1000);
            }
        }
        if (!header)
            throw new index_client_1.sdk.WERR_INTERNAL('no header should have returned false or thrown an error.');
        this.cache[height] = header.merkleRoot;
        if (header.merkleRoot !== root) {
            return false;
        }
        return true;
    }
}
exports.ChaintracksChainTracker = ChaintracksChainTracker;
//# sourceMappingURL=ChaintracksChainTracker.js.map