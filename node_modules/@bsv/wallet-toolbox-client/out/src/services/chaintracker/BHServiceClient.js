"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BHServiceClient = void 0;
const sdk_1 = require("@bsv/sdk");
const ChaintracksServiceClient_1 = require("./chaintracks/ChaintracksServiceClient");
const blockHeaderUtilities_1 = require("./chaintracks/util/blockHeaderUtilities");
class BHServiceClient {
    constructor(chain, url, apiKey) {
        this.bhs = new sdk_1.BlockHeadersService(url, { apiKey });
        this.cache = {};
        this.chain = chain;
        this.serviceUrl = url;
        this.options = ChaintracksServiceClient_1.ChaintracksServiceClient.createChaintracksServiceClientOptions();
        this.options.useAuthrite = true;
        this.apiKey = apiKey;
    }
    async currentHeight() {
        return await this.bhs.currentHeight();
    }
    async isValidRootForHeight(root, height) {
        const cachedRoot = this.cache[height];
        if (cachedRoot) {
            return cachedRoot === root;
        }
        const isValid = await this.bhs.isValidRootForHeight(root, height);
        this.cache[height] = root;
        return isValid;
    }
    async getPresentHeight() {
        return await this.bhs.currentHeight();
    }
    async findHeaderForHeight(height) {
        const response = await this.getJsonOrUndefined(`/api/v1/chain/header/byHeight?height=${height}`);
        const header = response === null || response === void 0 ? void 0 : response[0];
        if (!header)
            return undefined;
        const formatted = {
            version: header.version,
            previousHash: header.prevBlockHash,
            merkleRoot: header.merkleRoot,
            time: header.creationTimestamp,
            bits: header.difficultyTarget,
            nonce: header.nonce,
            height,
            hash: header.hash
        };
        return formatted;
    }
    async findHeaderForBlockHash(hash) {
        const response = await this.getJsonOrUndefined(`/api/v1/chain/header/state/${hash}`);
        if (!(response === null || response === void 0 ? void 0 : response.header))
            return undefined;
        const formatted = {
            version: response.header.version,
            previousHash: response.header.prevBlockHash,
            merkleRoot: response.header.merkleRoot,
            time: response.header.creationTimestamp,
            bits: response.header.difficultyTarget,
            nonce: response.header.nonce,
            height: response.height,
            hash: response.header.hash
        };
        return formatted;
    }
    async getHeaders(height, count) {
        const response = await this.getJsonOrUndefined(`/api/v1/chain/header/byHeight?height=${height}&count=${count}`);
        if (!response)
            return '';
        if (response.length < count)
            throw new Error('Cannot retrieve enough headers');
        const headers = response.map(response => {
            const header = {
                version: response.version,
                previousHash: response.prevBlockHash,
                merkleRoot: response.merkleRoot,
                time: response.creationTimestamp,
                bits: response.difficultyTarget,
                nonce: response.nonce
            };
            return (0, blockHeaderUtilities_1.serializeBlockHeader)(header);
        });
        return headers.reduce((str, arr) => str + sdk_1.Utils.toHex(arr), '');
    }
    async findChainWorkForBlockHash(hash) {
        throw new Error('Not implemented');
    }
    async findChainTipHeader() {
        const response = await this.getJson('/api/v1/chain/tip/longest');
        const formatted = {
            version: response.header.version,
            previousHash: response.header.prevBlockHash,
            merkleRoot: response.header.merkleRoot,
            time: response.header.creationTimestamp,
            bits: response.header.difficultyTarget,
            nonce: response.header.nonce,
            height: response.height,
            hash: response.header.hash
        };
        return formatted;
    }
    async getJsonOrUndefined(path) {
        let e = undefined;
        for (let retry = 0; retry < 3; retry++) {
            try {
                const r = await fetch(`${this.serviceUrl}${path}`, { headers: { Authorization: `Bearer ${this.apiKey}` } });
                if (r.status !== 200)
                    throw new Error(JSON.stringify(r));
                const v = await r.json();
                if (!v)
                    return undefined;
                return v;
            }
            catch (eu) {
                e = eu;
            }
            if (e && e.name !== 'ECONNRESET')
                break;
        }
        if (e)
            throw e;
    }
    async getJson(path) {
        const r = await this.getJsonOrUndefined(path);
        if (r === undefined)
            throw new Error('Value was undefined. Requested object may not exist.');
        return r;
    }
    /*
      Please note that all methods hereafter are included only to match the interface of ChaintracksServiceClient.
    */
    async postJsonVoid(path, params) {
        throw new Error('Not implemented');
    }
    async addHeader(header) {
        throw new Error('Not implemented');
    }
    async findHeaderForMerkleRoot(merkleRoot, height) {
        throw new Error('Not implemented');
    }
    async startListening() {
        throw new Error('Not implemented');
    }
    async listening() {
        throw new Error('Not implemented');
    }
    async isSynchronized() {
        throw new Error('Not implemented');
    }
    async getChain() {
        return this.chain;
    }
    async isListening() {
        throw new Error('Not implemented');
    }
    async getChainTipHeader() {
        throw new Error('Not implemented');
    }
    async findChainTipHashHex() {
        throw new Error('Not implemented');
    }
}
exports.BHServiceClient = BHServiceClient;
//# sourceMappingURL=BHServiceClient.js.map