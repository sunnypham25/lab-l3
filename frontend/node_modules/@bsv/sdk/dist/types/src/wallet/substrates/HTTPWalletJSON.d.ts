import { WalletInterface, CreateActionArgs, OriginatorDomainNameStringUnder250Bytes, CreateActionResult, BooleanDefaultTrue, AcquireCertificateArgs, AcquireCertificateResult, Base64String, BasketStringUnder300Bytes, BooleanDefaultFalse, Byte, CertificateFieldNameUnder50Bytes, DescriptionString5to50Bytes, DiscoverCertificatesResult, HexString, InternalizeActionArgs, ISOTimestampString, KeyIDStringUnder800Bytes, ListActionsArgs, ListActionsResult, ListCertificatesResult, ListOutputsArgs, ListOutputsResult, OutpointString, PositiveInteger, PositiveIntegerDefault10Max10000, PositiveIntegerOrZero, ProtocolString5To400Bytes, ProveCertificateArgs, ProveCertificateResult, PubKeyHex, SecurityLevel, SignActionArgs, SignActionResult, VersionString7To30Bytes } from '../Wallet.interfaces.js';
export default class HTTPWalletJSON implements WalletInterface {
    baseUrl: string;
    httpClient: typeof fetch;
    originator: OriginatorDomainNameStringUnder250Bytes | undefined;
    api: (call: string, args: object) => Promise<unknown>;
    constructor(originator: OriginatorDomainNameStringUnder250Bytes | undefined, baseUrl?: string, httpClient?: typeof fetch);
    createAction(args: CreateActionArgs): Promise<CreateActionResult>;
    signAction(args: SignActionArgs): Promise<SignActionResult>;
    abortAction(args: {
        reference: Base64String;
    }): Promise<{
        aborted: true;
    }>;
    listActions(args: ListActionsArgs): Promise<ListActionsResult>;
    internalizeAction(args: InternalizeActionArgs): Promise<{
        accepted: true;
    }>;
    listOutputs(args: ListOutputsArgs): Promise<ListOutputsResult>;
    relinquishOutput(args: {
        basket: BasketStringUnder300Bytes;
        output: OutpointString;
    }): Promise<{
        relinquished: true;
    }>;
    getPublicKey(args: {
        seekPermission?: BooleanDefaultTrue;
        identityKey?: true;
        protocolID?: [SecurityLevel, ProtocolString5To400Bytes];
        keyID?: KeyIDStringUnder800Bytes;
        privileged?: BooleanDefaultFalse;
        privilegedReason?: DescriptionString5to50Bytes;
        counterparty?: PubKeyHex | 'self' | 'anyone';
        forSelf?: BooleanDefaultFalse;
    }): Promise<{
        publicKey: PubKeyHex;
    }>;
    revealCounterpartyKeyLinkage(args: {
        counterparty: PubKeyHex;
        verifier: PubKeyHex;
        privilegedReason?: DescriptionString5to50Bytes;
        privileged?: BooleanDefaultFalse;
    }): Promise<{
        prover: PubKeyHex;
        verifier: PubKeyHex;
        counterparty: PubKeyHex;
        revelationTime: ISOTimestampString;
        encryptedLinkage: Byte[];
        encryptedLinkageProof: number[];
    }>;
    revealSpecificKeyLinkage(args: {
        counterparty: PubKeyHex;
        verifier: PubKeyHex;
        protocolID: [SecurityLevel, ProtocolString5To400Bytes];
        keyID: KeyIDStringUnder800Bytes;
        privilegedReason?: DescriptionString5to50Bytes;
        privileged?: BooleanDefaultFalse;
    }): Promise<{
        prover: PubKeyHex;
        verifier: PubKeyHex;
        counterparty: PubKeyHex;
        protocolID: [SecurityLevel, ProtocolString5To400Bytes];
        keyID: KeyIDStringUnder800Bytes;
        encryptedLinkage: Byte[];
        encryptedLinkageProof: Byte[];
        proofType: Byte;
    }>;
    encrypt(args: {
        seekPermission?: BooleanDefaultTrue;
        plaintext: Byte[];
        protocolID: [SecurityLevel, ProtocolString5To400Bytes];
        keyID: KeyIDStringUnder800Bytes;
        privilegedReason?: DescriptionString5to50Bytes;
        counterparty?: PubKeyHex | 'self' | 'anyone';
        privileged?: BooleanDefaultFalse;
    }): Promise<{
        ciphertext: Byte[];
    }>;
    decrypt(args: {
        seekPermission?: BooleanDefaultTrue;
        ciphertext: Byte[];
        protocolID: [SecurityLevel, ProtocolString5To400Bytes];
        keyID: KeyIDStringUnder800Bytes;
        privilegedReason?: DescriptionString5to50Bytes;
        counterparty?: PubKeyHex | 'self' | 'anyone';
        privileged?: BooleanDefaultFalse;
    }): Promise<{
        plaintext: Byte[];
    }>;
    createHmac(args: {
        seekPermission?: BooleanDefaultTrue;
        data: Byte[];
        protocolID: [SecurityLevel, ProtocolString5To400Bytes];
        keyID: KeyIDStringUnder800Bytes;
        privilegedReason?: DescriptionString5to50Bytes;
        counterparty?: PubKeyHex | 'self' | 'anyone';
        privileged?: BooleanDefaultFalse;
    }): Promise<{
        hmac: Byte[];
    }>;
    verifyHmac(args: {
        seekPermission?: BooleanDefaultTrue;
        data: Byte[];
        hmac: Byte[];
        protocolID: [SecurityLevel, ProtocolString5To400Bytes];
        keyID: KeyIDStringUnder800Bytes;
        privilegedReason?: DescriptionString5to50Bytes;
        counterparty?: PubKeyHex | 'self' | 'anyone';
        privileged?: BooleanDefaultFalse;
    }): Promise<{
        valid: true;
    }>;
    createSignature(args: {
        seekPermission?: BooleanDefaultTrue;
        data?: Byte[];
        hashToDirectlySign?: Byte[];
        protocolID: [SecurityLevel, ProtocolString5To400Bytes];
        keyID: KeyIDStringUnder800Bytes;
        privilegedReason?: DescriptionString5to50Bytes;
        counterparty?: PubKeyHex | 'self' | 'anyone';
        privileged?: BooleanDefaultFalse;
    }): Promise<{
        signature: Byte[];
    }>;
    verifySignature(args: {
        seekPermission?: BooleanDefaultTrue;
        data?: Byte[];
        hashToDirectlyVerify?: Byte[];
        signature: Byte[];
        protocolID: [SecurityLevel, ProtocolString5To400Bytes];
        keyID: KeyIDStringUnder800Bytes;
        privilegedReason?: DescriptionString5to50Bytes;
        counterparty?: PubKeyHex | 'self' | 'anyone';
        forSelf?: BooleanDefaultFalse;
        privileged?: BooleanDefaultFalse;
    }): Promise<{
        valid: true;
    }>;
    acquireCertificate(args: AcquireCertificateArgs): Promise<AcquireCertificateResult>;
    listCertificates(args: {
        certifiers: PubKeyHex[];
        types: Base64String[];
        limit?: PositiveIntegerDefault10Max10000;
        offset?: PositiveIntegerOrZero;
        privileged?: BooleanDefaultFalse;
        privilegedReason?: DescriptionString5to50Bytes;
    }): Promise<ListCertificatesResult>;
    proveCertificate(args: ProveCertificateArgs): Promise<ProveCertificateResult>;
    relinquishCertificate(args: {
        type: Base64String;
        serialNumber: Base64String;
        certifier: PubKeyHex;
    }): Promise<{
        relinquished: true;
    }>;
    discoverByIdentityKey(args: {
        seekPermission?: BooleanDefaultTrue;
        identityKey: PubKeyHex;
        limit?: PositiveIntegerDefault10Max10000;
        offset?: PositiveIntegerOrZero;
    }): Promise<DiscoverCertificatesResult>;
    discoverByAttributes(args: {
        seekPermission?: BooleanDefaultTrue;
        attributes: Record<CertificateFieldNameUnder50Bytes, string>;
        limit?: PositiveIntegerDefault10Max10000;
        offset?: PositiveIntegerOrZero;
    }): Promise<DiscoverCertificatesResult>;
    isAuthenticated(args: object): Promise<{
        authenticated: true;
    }>;
    waitForAuthentication(args: object): Promise<{
        authenticated: true;
    }>;
    getHeight(args: object): Promise<{
        height: PositiveInteger;
    }>;
    getHeaderForHeight(args: {
        height: PositiveInteger;
    }): Promise<{
        header: HexString;
    }>;
    getNetwork(args: object): Promise<{
        network: 'mainnet' | 'testnet';
    }>;
    getVersion(args: object): Promise<{
        version: VersionString7To30Bytes;
    }>;
}
//# sourceMappingURL=HTTPWalletJSON.d.ts.map