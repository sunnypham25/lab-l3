import ReductionContext from './ReductionContext.js';
/**
 * JavaScript numbers are only precise up to 53 bits. Since Bitcoin relies on
 * 256-bit cryptography, this BigNumber class enables operations on larger
 * numbers.
 *
 * @class BigNumber
 */
export default class BigNumber {
    /**
     * @privateinitializer
     */
    static readonly zeros: string[];
    /**
     * @privateinitializer
     */
    static readonly groupSizes: number[];
    /**
     * @privateinitializer
     */
    static readonly groupBases: number[];
    /**
     * The word size of big number chunks.
     *
     * @property wordSize
     *
     * @example
     * console.log(BigNumber.wordSize);  // output: 26
     */
    static readonly wordSize: number;
    private static readonly WORD_SIZE_BIGINT;
    private static readonly WORD_MASK;
    private static readonly MAX_SAFE_INTEGER_BIGINT;
    private static readonly MIN_SAFE_INTEGER_BIGINT;
    private static readonly MAX_IMULN_ARG;
    private static readonly MAX_NUMBER_CONSTRUCTOR_MAG_BIGINT;
    private _magnitude;
    private _sign;
    private _nominalWordLength;
    /**
     * Reduction context of the big number.
     *
     * @property red
     */
    red: ReductionContext | null;
    /**
     * Negative flag. Indicates whether the big number is a negative number.
     * - If 0, the number is positive.
     * - If 1, the number is negative.
     *
     * @property negative
     */
    get negative(): number;
    /**
     * Sets the negative flag. Only 0 (positive) or 1 (negative) are allowed.
     */
    set negative(val: number);
    private get _computedWordsArray();
    /**
     * Array of numbers, where each number represents a part of the value of the big number.
     *
     * @property words
     */
    get words(): number[];
    /**
     * Sets the words array representing the value of the big number.
     */
    set words(newWords: number[]);
    /**
     * Length of the words array.
     *
     * @property length
     */
    get length(): number;
    /**
     * Checks whether a value is an instance of BigNumber. Regular JS numbers fail this check.
     *
     * @method isBN
     * @param num - The value to be checked.
     * @returns - Returns a boolean value determining whether or not the checked num parameter is a BigNumber.
     */
    static isBN(num: any): boolean;
    /**
     * Returns the bigger value between two BigNumbers
     *
     * @method max
     * @param left - The first BigNumber to be compared.
     * @param right - The second BigNumber to be compared.
     * @returns - Returns the bigger BigNumber between left and right.
     */
    static max(left: BigNumber, right: BigNumber): BigNumber;
    /**
     * Returns the smaller value between two BigNumbers
     *
     * @method min
     * @param left - The first BigNumber to be compared.
     * @param right - The second BigNumber to be compared.
     * @returns - Returns the smaller value between left and right.
     */
    static min(left: BigNumber, right: BigNumber): BigNumber;
    /**
     * @constructor
     *
     * @param number - The number (various types accepted) to construct a BigNumber from. Default is 0.
     * @param base - The base of number provided. By default is 10.
     * @param endian - The endianness provided. By default is 'big endian'.
     */
    constructor(number?: number | string | number[] | bigint | undefined, base?: number | 'be' | 'le' | 'hex', endian?: 'be' | 'le');
    private _bigIntToStringInBase;
    private _parseBaseString;
    private _parseBaseWord;
    private _initializeState;
    private _finishInitialization;
    private assert;
    private initNumber;
    private initArray;
    copy(dest: BigNumber): void;
    static move(dest: BigNumber, src: BigNumber): void;
    clone(): BigNumber;
    expand(size: number): this;
    strip(): this;
    normSign(): this;
    inspect(): string;
    private _getMinimalHex;
    /**
     * Converts the BigNumber instance to a string representation.
     *
     * @method toString
     * @param base - The base for representing number. Default is 10. Other accepted values are 16 and 'hex'.
     * @param padding - Represents the minimum number of digits to represent the BigNumber as a string. Default is 1.
     * @returns The string representation of the BigNumber instance
     */
    toString(base?: number | 'hex', padding?: number): string;
    private toBaseString;
    /**
     * Converts the BigNumber instance to a JavaScript number.
     * Please note that JavaScript numbers are only precise up to 53 bits.
     *
     * @method toNumber
     * @throws If the BigNumber instance cannot be safely stored in a JavaScript number
     * @returns The JavaScript number representation of the BigNumber instance.
     */
    toNumber(): number;
    /**
     * Converts the BigNumber instance to a JSON-formatted string.
     *
     * @method toJSON
     * @returns The JSON string representation of the BigNumber instance.
     */
    toJSON(): string;
    private toArrayLikeGeneric;
    /**
     * Converts the BigNumber instance to an array of bytes.
     *
     * @method toArray
     * @param endian - Endianness of the output array, defaults to 'be'.
     * @param length - Optional length of the output array.
     * @returns Array of bytes representing the BigNumber.
     */
    toArray(endian?: 'le' | 'be', length?: number): number[];
    /**
     * Calculates the number of bits required to represent the BigNumber.
     *
     * @method bitLength
     * @returns The bit length of the BigNumber.
     */
    bitLength(): number;
    /**
     * Converts a BigNumber to an array of bits.
     *
     * @method toBitArray
     * @param num - The BigNumber to convert.
     * @returns An array of bits.
     */
    static toBitArray(num: BigNumber): Array<0 | 1>;
    /**
     * Instance version of {@link toBitArray}.
     */
    toBitArray(): Array<0 | 1>;
    /**
     * Returns the number of trailing zero bits in the big number.
     *
     * @method zeroBits
     * @returns Returns the number of trailing zero bits
     * in the binary representation of the big number.
     *
     * @example
     * const bn = new BigNumber('8'); // binary: 1000
     * const zeroBits = bn.zeroBits(); // 3
     */
    zeroBits(): number;
    /**
     * Calculates the number of bytes required to represent the BigNumber.
     *
     * @method byteLength
     * @returns The byte length of the BigNumber.
     */
    byteLength(): number;
    private _getSignedValue;
    private _setValueFromSigned;
    toTwos(width: number): BigNumber;
    fromTwos(width: number): BigNumber;
    isNeg(): boolean;
    neg(): BigNumber;
    ineg(): this;
    private _iuop;
    iuor(num: BigNumber): this;
    iuand(num: BigNumber): this;
    iuxor(num: BigNumber): this;
    private _iop;
    ior(num: BigNumber): this;
    iand(num: BigNumber): this;
    ixor(num: BigNumber): this;
    private _uop_new;
    or(num: BigNumber): BigNumber;
    uor(num: BigNumber): BigNumber;
    and(num: BigNumber): BigNumber;
    uand(num: BigNumber): BigNumber;
    xor(num: BigNumber): BigNumber;
    uxor(num: BigNumber): BigNumber;
    inotn(width: number): this;
    notn(width: number): BigNumber;
    setn(bit: number, val: any): this;
    iadd(num: BigNumber): this;
    add(num: BigNumber): BigNumber;
    isub(num: BigNumber): this;
    sub(num: BigNumber): BigNumber;
    mul(num: BigNumber): BigNumber;
    imul(num: BigNumber): this;
    imuln(num: number): this;
    muln(num: number): BigNumber;
    sqr(): BigNumber;
    isqr(): this;
    pow(num: BigNumber): BigNumber;
    iushln(bits: number): this;
    ishln(bits: number): this;
    iushrn(bits: number, hint?: number, extended?: BigNumber): this;
    ishrn(bits: number, hint?: number, extended?: BigNumber): this;
    shln(bits: number): BigNumber;
    ushln(bits: number): BigNumber;
    shrn(bits: number): BigNumber;
    ushrn(bits: number): BigNumber;
    testn(bit: number): boolean;
    imaskn(bits: number): this;
    maskn(bits: number): BigNumber;
    iaddn(num: number): this;
    _iaddn(num: number): this;
    isubn(num: number): this;
    addn(num: number): BigNumber;
    subn(num: number): BigNumber;
    iabs(): this;
    abs(): BigNumber;
    divmod(num: BigNumber, mode?: 'div' | 'mod', positive?: boolean): any;
    div(num: BigNumber): BigNumber;
    mod(num: BigNumber): BigNumber;
    umod(num: BigNumber): BigNumber;
    divRound(num: BigNumber): BigNumber;
    modrn(numArg: number): number;
    idivn(num: number): this;
    divn(num: number): BigNumber;
    egcd(p: BigNumber): {
        a: BigNumber;
        b: BigNumber;
        gcd: BigNumber;
    };
    gcd(num: BigNumber): BigNumber;
    invm(num: BigNumber): BigNumber;
    isEven(): boolean;
    isOdd(): boolean;
    andln(num: number): number;
    bincn(bit: number): this;
    isZero(): boolean;
    cmpn(num: number): 1 | 0 | -1;
    cmp(num: BigNumber): 1 | 0 | -1;
    ucmp(num: BigNumber): 1 | 0 | -1;
    gtn(num: number): boolean;
    gt(num: BigNumber): boolean;
    gten(num: number): boolean;
    gte(num: BigNumber): boolean;
    ltn(num: number): boolean;
    lt(num: BigNumber): boolean;
    lten(num: number): boolean;
    lte(num: BigNumber): boolean;
    eqn(num: number): boolean;
    eq(num: BigNumber): boolean;
    toRed(ctx: ReductionContext): BigNumber;
    fromRed(): BigNumber;
    forceRed(ctx: ReductionContext): this;
    redAdd(num: BigNumber): BigNumber;
    redIAdd(num: BigNumber): BigNumber;
    redSub(num: BigNumber): BigNumber;
    redISub(num: BigNumber): BigNumber;
    redShl(num: number): BigNumber;
    redMul(num: BigNumber): BigNumber;
    redIMul(num: BigNumber): BigNumber;
    redSqr(): BigNumber;
    redISqr(): BigNumber;
    redSqrt(): BigNumber;
    redInvm(): BigNumber;
    redNeg(): BigNumber;
    redPow(num: BigNumber): BigNumber;
    /**
     * Creates a BigNumber from a hexadecimal string.
     *
     * @static
     * @method fromHex
     * @param hex - The hexadecimal string to create a BigNumber from.
     * @param endian - Optional endianness for parsing the hex string.
     * @returns Returns a BigNumber created from the hexadecimal input string.
     *
     * @example
     * const exampleHex = 'a1b2c3';
     * const bigNumber = BigNumber.fromHex(exampleHex);
     */
    static fromHex(hex: string, endian?: 'le' | 'be' | 'little' | 'big'): BigNumber;
    /**
     * Converts this BigNumber to a hexadecimal string.
     *
     * @method toHex
     * @param length - The minimum length of the hex string
     * @returns Returns a string representing the hexadecimal value of this BigNumber.
     *
     * @example
     * const bigNumber = new BigNumber(255)
     * const hex = bigNumber.toHex()
     */
    toHex(byteLength?: number): string;
    /**
     * Creates a BigNumber from a JSON-serialized string.
     *
     * @static
     * @method fromJSON
     * @param str - The JSON-serialized string to create a BigNumber from.
     * @returns Returns a BigNumber created from the JSON input string.
     */
    static fromJSON(str: string): BigNumber;
    /**
     * Creates a BigNumber from a number.
     *
     * @static
     * @method fromNumber
     * @param n - The number to create a BigNumber from.
     * @returns Returns a BigNumber equivalent to the input number.
     */
    static fromNumber(n: number): BigNumber;
    /**
     * Creates a BigNumber from a string, considering an optional base.
     *
     * @static
     * @method fromString
     * @param str - The string to create a BigNumber from.
     * @param base - The base used for conversion. If not provided, base 10 is assumed.
     * @returns Returns a BigNumber equivalent to the string after conversion from the specified base.
     */
    static fromString(str: string, base?: number | 'hex'): BigNumber;
    /**
     * Creates a BigNumber from a signed magnitude number.
     *
     * @static
     * @method fromSm
     * @param bytes - The signed magnitude number to convert to a BigNumber.
     * @param endian - Defines endianess. If not provided, big endian is assumed.
     * @returns Returns a BigNumber equivalent to the signed magnitude number interpreted with specified endianess.
     */
    static fromSm(bytes: number[], endian?: 'big' | 'little'): BigNumber;
    /**
     * Converts this BigNumber to a signed magnitude number.
     *
     * @method toSm
     * @param endian - Defines endianess. If not provided, big endian is assumed.
     * @returns Returns an array equivalent to this BigNumber interpreted as a signed magnitude with specified endianess.
     */
    toSm(endian?: 'big' | 'little'): number[];
    /**
     * Creates a BigNumber from a number representing the "bits" value in a block header.
     *
     * @static
     * @method fromBits
     * @param bits - The number representing the bits value in a block header.
     * @param strict - If true, an error is thrown if the number has negative bit set.
     * @returns Returns a BigNumber equivalent to the "bits" value in a block header.
     * @throws Will throw an error if `strict` is `true` and the number has negative bit set.
     */
    static fromBits(bits: number, strict?: boolean): BigNumber;
    /**
     * Converts this BigNumber to a number representing the "bits" value in a block header.
     *
     * @method toBits
     * @returns Returns a number equivalent to the "bits" value in a block header.
     */
    toBits(): number;
    /**
     * Creates a BigNumber from the format used in Bitcoin scripts.
     *
     * @static
     * @method fromScriptNum
     * @param num - The number in the format used in Bitcoin scripts.
     * @param requireMinimal - If true, non-minimally encoded values will throw an error.
     * @param maxNumSize - The maximum allowed size for the number.
     * @returns Returns a BigNumber equivalent to the number used in a Bitcoin script.
     */
    static fromScriptNum(num: number[], requireMinimal?: boolean, maxNumSize?: number): BigNumber;
    /**
     * Converts this BigNumber to a number in the format used in Bitcoin scripts.
     *
     * @method toScriptNum
     * @returns Returns the equivalent to this BigNumber as a Bitcoin script number.
     */
    toScriptNum(): number[];
    /**
     * Compute the multiplicative inverse of the current BigNumber in the modulus field specified by `p`.
     * The multiplicative inverse is a number which when multiplied with the current BigNumber gives '1' in the modulus field.
     *
     * @method _invmp
     * @param p - The `BigNumber` specifying the modulus field.
     * @returns The multiplicative inverse `BigNumber` in the modulus field specified by `p`.
     */
    _invmp(p: BigNumber): BigNumber;
    /**
     * Performs multiplication between the BigNumber instance and a given BigNumber.
     * It chooses the multiplication method based on the lengths of the numbers to optimize execution time.
     *
     * @method mulTo
     * @param num - The BigNumber multiply with.
     * @param out - The BigNumber where to store the result.
     * @returns The BigNumber resulting from the multiplication operation.
     */
    mulTo(num: BigNumber, out: BigNumber): BigNumber;
}
//# sourceMappingURL=BigNumber.d.ts.map