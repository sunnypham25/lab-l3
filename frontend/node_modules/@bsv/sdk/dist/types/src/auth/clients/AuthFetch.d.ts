import { WalletInterface } from '../../wallet/Wallet.interfaces.js';
import { Peer } from '../Peer.js';
import { SessionManager } from '../SessionManager.js';
import { RequestedCertificateSet } from '../types.js';
import { VerifiableCertificate } from '../certificates/VerifiableCertificate.js';
interface SimplifiedFetchRequestOptions {
    method?: string;
    headers?: Record<string, string>;
    body?: any;
    retryCounter?: number;
}
interface AuthPeer {
    peer: Peer;
    identityKey?: string;
    supportsMutualAuth?: boolean;
    pendingCertificateRequests: Array<true>;
}
/**
 * AuthFetch provides a lightweight fetch client for interacting with servers
 * over a simplified HTTP transport mechanism. It integrates session management, peer communication,
 * and certificate handling to enable secure and mutually-authenticated requests.
 *
 * Additionally, it automatically handles 402 Payment Required responses by creating
 * and sending BSV payment transactions when necessary.
 */
export declare class AuthFetch {
    private readonly sessionManager;
    private readonly wallet;
    private callbacks;
    private readonly certificatesReceived;
    private readonly requestedCertificates?;
    peers: Record<string, AuthPeer>;
    /**
    * Constructs a new AuthFetch instance.
    * @param wallet - The wallet instance for signing and authentication.
    * @param requestedCertificates - Optional set of certificates to request from peers.
    */
    constructor(wallet: WalletInterface, requestedCertificates?: RequestedCertificateSet, sessionManager?: SessionManager);
    /**
     * Mutually authenticates and sends a HTTP request to a server.
     *
     * 1) Attempt the request.
     * 2) If 402 Payment Required, automatically create and send payment.
     * 3) Return the final response.
     *
     * @param url - The URL to send the request to.
     * @param config - Configuration options for the request, including method, headers, and body.
     * @returns A promise that resolves with the server's response, structured as a Response-like object.
     *
     * @throws Will throw an error if unsupported headers are used or other validation fails.
     */
    fetch(url: string, config?: SimplifiedFetchRequestOptions): Promise<Response>;
    /**
     * Request Certificates from a Peer
     * @param baseUrl
     * @param certificatesToRequest
     */
    sendCertificateRequest(baseUrl: string, certificatesToRequest: RequestedCertificateSet): Promise<VerifiableCertificate[]>;
    /**
     * Return any certificates we've collected thus far, then clear them out.
     */
    consumeReceivedCertificates(): VerifiableCertificate[];
    /**
     * Serializes the HTTP request to be sent over the Transport.
     *
     * @param method - The HTTP method (e.g., 'GET', 'POST') for the request.
     * @param headers - A record of HTTP headers to include in the request.
     * @param body - The body of the request, if applicable (e.g., for POST/PUT requests).
     * @param parsedUrl - The parsed URL object containing the full request URL.
     * @param requestNonce - A unique random nonce to ensure request integrity.
     * @returns A promise that resolves to a `Writer` containing the serialized request.
     *
     * @throws Will throw an error if unsupported headers are used or serialization fails.
     */
    private serializeRequest;
    /**
     * Handles a non-authenticated fetch requests and validates that the server is not claiming to be authenticated.
     */
    private handleFetchAndValidate;
    /**
     * If we get 402 Payment Required, we build a transaction via wallet.createAction()
     * and re-attempt the request with an x-bsv-payment header.
     */
    private handlePaymentAndRetry;
    private normalizeBodyToNumberArray;
}
export {};
//# sourceMappingURL=AuthFetch.d.ts.map