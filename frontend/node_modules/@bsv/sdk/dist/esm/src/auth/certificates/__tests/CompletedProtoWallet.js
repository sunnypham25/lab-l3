//@ts-nocheck
import PrivateKey from '../../../primitives/PrivateKey.js';
import { ProtoWallet, KeyDeriver, CachedKeyDeriver } from '../../../wallet/index.js';
// Test Mock wallet which extends ProtoWallet but still implements Wallet interface
// Unsupported methods throw
export class CompletedProtoWallet extends ProtoWallet {
    keyDeriver;
    constructor(rootKeyOrKeyDeriver) {
        super(rootKeyOrKeyDeriver);
        if (rootKeyOrKeyDeriver instanceof KeyDeriver) {
            this.keyDeriver = rootKeyOrKeyDeriver;
        }
        else if (typeof rootKeyOrKeyDeriver === 'string' ||
            rootKeyOrKeyDeriver instanceof PrivateKey) {
            this.keyDeriver = new CachedKeyDeriver(rootKeyOrKeyDeriver);
        }
        else {
            throw new Error('Invalid key deriver provided');
        }
    }
    async isAuthenticated() {
        throw new Error('not implemented');
    }
    async waitForAuthentication() {
        throw new Error('not implemented');
    }
    async getNetwork() {
        throw new Error('not implemented');
    }
    async getVersion() {
        throw new Error('not implemented');
    }
    async getPublicKey(args) {
        if (args.privileged === true) {
            throw new Error('no privilege support');
        }
        if (args.identityKey === true) {
            if (this.keyDeriver === null || this.keyDeriver === undefined) {
                throw new Error('keyDeriver is not initialized');
            }
            return { publicKey: this.keyDeriver.rootKey.toPublicKey().toString() };
        }
        else {
            if (args.protocolID == null || typeof args.keyID !== 'string' || args.keyID.trim() === '') {
                throw new Error('protocolID and keyID are required if identityKey is false or undefined.');
            }
            if (this.keyDeriver === null || this.keyDeriver === undefined) {
                throw new Error('keyDeriver is not initialized');
            }
            return {
                publicKey: this.keyDeriver
                    .derivePublicKey(args.protocolID, args.keyID, typeof args.counterparty === 'string' && args.counterparty.trim() !== ''
                    ? args.counterparty
                    : 'self', Boolean(args.forSelf))
                    .toString()
            };
        }
    }
    async createAction() {
        throw new Error('not implemented');
    }
    async signAction() {
        throw new Error('not implemented');
    }
    async abortAction() {
        throw new Error('not implemented');
    }
    async listActions() {
        throw new Error('not implemented');
    }
    async internalizeAction() {
        throw new Error('not implemented');
    }
    async listOutputs() {
        throw new Error('not implemented');
    }
    async relinquishOutput() {
        throw new Error('not implemented');
    }
    async acquireCertificate() {
        throw new Error('not implemented');
    }
    async listCertificates() {
        throw new Error('not implemented');
    }
    async proveCertificate() {
        throw new Error('not implemented');
    }
    async relinquishCertificate() {
        throw new Error('not implemented');
    }
    async discoverByIdentityKey() {
        throw new Error('not implemented');
    }
    async discoverByAttributes() {
        throw new Error('not implemented');
    }
    async getHeight() {
        throw new Error('not implemented');
    }
    async getHeaderForHeight() {
        throw new Error('not implemented');
    }
}
//# sourceMappingURL=CompletedProtoWallet.js.map