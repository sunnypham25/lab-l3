"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.verify = exports.sign = exports.magicHash = void 0;
const BigNumber_js_1 = __importDefault(require("../primitives/BigNumber.js"));
const utils_js_1 = require("../primitives/utils.js");
const ECDSA = __importStar(require("../primitives/ECDSA.js"));
const Hash = __importStar(require("../primitives/Hash.js"));
const prefix = 'Bitcoin Signed Message:\n';
/**
 * Generates a SHA256 double-hash of the prefixed message.
 * @deprecated Replaced by BRC-77 which uses a more secure and private method for message signing.
 * @param messageBuf The message buffer to be hashed.
 * @returns The double-hash of the prefixed message as a number array.
 */
const magicHash = (messageBuf) => {
    const bw = new utils_js_1.Writer();
    bw.writeVarIntNum(prefix.length);
    bw.write((0, utils_js_1.toArray)(prefix, 'utf8'));
    bw.writeVarIntNum(messageBuf.length);
    bw.write(messageBuf);
    const buf = bw.toArray();
    const hashBuf = Hash.hash256(buf);
    return hashBuf;
};
exports.magicHash = magicHash;
/**
 * Signs a BSM message using the given private key.
 * @deprecated Replaced by BRC-77 which employs BRC-42 key derivation and BRC-43 invoice numbers for enhanced security and privacy.
 * @param message The message to be signed as a number array.
 * @param privateKey The private key used for signing the message.
 * @param mode The mode of operation. When "base64", the BSM format signature is returned. When "raw", a Signature object is returned. Default: "base64".
 * @returns The signature object when in raw mode, or the BSM base64 string when in base64 mode.
 */
const sign = (message, privateKey, mode = 'base64') => {
    const hashBuf = (0, exports.magicHash)(message);
    const sig = ECDSA.sign(new BigNumber_js_1.default(hashBuf), privateKey, true);
    if (mode === 'raw') {
        return sig;
    }
    const h = new BigNumber_js_1.default(hashBuf);
    const r = sig.CalculateRecoveryFactor(privateKey.toPublicKey(), h);
    return sig.toCompact(r, true, 'base64');
};
exports.sign = sign;
/**
 * Verifies a BSM signed message using the given public key.
 * @deprecated Replaced by BRC-77 which provides privately-verifiable signatures and avoids key reuse.
 * @param message The message to be verified as a number array.
 * @param sig The signature object.
 * @param pubKey The public key for verification.
 * @returns True if the signature is valid, false otherwise.
 */
const verify = (message, sig, pubKey) => {
    const hashBuf = (0, exports.magicHash)(message);
    return ECDSA.verify(new BigNumber_js_1.default(hashBuf), sig, pubKey);
};
exports.verify = verify;
//# sourceMappingURL=BSM.js.map