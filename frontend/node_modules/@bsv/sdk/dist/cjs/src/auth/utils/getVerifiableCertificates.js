"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getVerifiableCertificates = void 0;
const VerifiableCertificate_js_1 = require("../certificates/VerifiableCertificate.js");
/**
 * Retrieves an array of verifiable certificates based on the request.
 *
 * @private
 * @param {RequestedCertificateSet} requestedCertificates - The set of certificates requested by the peer.
 * @param {string} verifierIdentityKey - The public key of the verifier requesting the certificates.
 * @returns {Promise<VerifiableCertificate[]>} An array of verifiable certificates.
 */
const getVerifiableCertificates = async (wallet, requestedCertificates, verifierIdentityKey) => {
    // Find matching certificates we have
    // Note: This may return multiple certificates that match the correct type.
    const matchingCertificates = await wallet.listCertificates({
        certifiers: requestedCertificates.certifiers,
        types: Object.keys(requestedCertificates.types)
    });
    // For each certificate requested, create a verifiable cert with selectively revealed fields
    return await Promise.all(matchingCertificates.certificates.map(async (certificate) => {
        const { keyringForVerifier } = await wallet.proveCertificate({
            certificate,
            fieldsToReveal: requestedCertificates.types[certificate.type],
            verifier: verifierIdentityKey
        });
        return new VerifiableCertificate_js_1.VerifiableCertificate(certificate.type, certificate.serialNumber, certificate.subject, certificate.certifier, certificate.revocationOutpoint, certificate.fields, keyringForVerifier, certificate.signature);
    }));
};
exports.getVerifiableCertificates = getVerifiableCertificates;
//# sourceMappingURL=getVerifiableCertificates.js.map