"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-env jest */
const MessageBoxClient_js_1 = require("../../MessageBoxClient.js");
const sdk_1 = require("@bsv/sdk");
const crypto_1 = require("crypto");
const globals_1 = require("@jest/globals");
global.self = { crypto: crypto_1.webcrypto };
jest.setTimeout(20000);
const walletClient = new sdk_1.WalletClient('json-api', 'https://messagebox.babbage.systems');
const messageBoxClient = new MessageBoxClient_js_1.MessageBoxClient({
    host: 'https://messagebox.babbage.systems',
    walletClient,
    enableLogging: true,
    networkPreset: 'local'
});
let identityKey;
(0, globals_1.describe)('Encryption Integration Tests', () => {
    const messageBox = 'testBox';
    const plaintext = 'This is a secure test message.';
    (0, globals_1.beforeAll)(async () => {
        const result = await walletClient.getPublicKey({ identityKey: true });
        identityKey = result.publicKey;
        await messageBoxClient.initializeConnection();
    });
    (0, globals_1.test)('encrypts and decrypts a message to self successfully', async () => {
        // Encrypt
        const { ciphertext } = await walletClient.encrypt({
            plaintext: Array.from(new TextEncoder().encode(plaintext)),
            protocolID: [1, 'messagebox'],
            keyID: '1',
            counterparty: 'self'
        });
        (0, globals_1.expect)(Array.isArray(ciphertext)).toBe(true);
        (0, globals_1.expect)(ciphertext.length).toBeGreaterThan(0);
        // Decrypt
        const { plaintext: decryptedBytes } = await walletClient.decrypt({
            ciphertext,
            protocolID: [1, 'messagebox'],
            keyID: '1',
            counterparty: 'self'
        });
        const decrypted = new TextDecoder().decode(Uint8Array.from(decryptedBytes));
        (0, globals_1.expect)(decrypted).toBe(plaintext);
    });
    (0, globals_1.test)('sends and receives encrypted message using MessageBoxClient', async () => {
        // Send message to self
        const sendResult = await messageBoxClient.sendMessage({
            recipient: identityKey,
            messageBox,
            body: plaintext
        });
        (0, globals_1.expect)(sendResult.status).toBe('success');
        (0, globals_1.expect)(typeof sendResult.messageId).toBe('string');
        // List and decrypt
        const messages = await messageBoxClient.listMessages({ messageBox });
        const last = messages.at(-1);
        (0, globals_1.expect)(last).toBeDefined();
        (0, globals_1.expect)(last === null || last === void 0 ? void 0 : last.body).toBe(plaintext);
    });
    (0, globals_1.test)('encrypted message is not stored or transmitted as plaintext', async () => {
        var _a;
        // Send encrypted message to self
        const sendResult = await messageBoxClient.sendMessage({
            recipient: identityKey,
            messageBox,
            body: plaintext
        });
        (0, globals_1.expect)(sendResult.status).toBe('success');
        // Manually fetch raw HTTP response
        const fetch = await messageBoxClient.authFetch.fetch('https://messagebox.babbage.systems/listMessages', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ messageBox })
        });
        const raw = await fetch.json();
        const rawBody = (_a = raw.messages.at(-1)) === null || _a === void 0 ? void 0 : _a.body;
        (0, globals_1.expect)(typeof rawBody).toBe('string');
        const parsed = JSON.parse(rawBody);
        (0, globals_1.expect)(typeof parsed.encryptedMessage).toBe('string');
        (0, globals_1.expect)(parsed.encryptedMessage.includes(plaintext)).toBe(false);
    });
});
//# sourceMappingURL=integrationEncrypted.test.js.map